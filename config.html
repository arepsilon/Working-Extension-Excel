<!DOCTYPE html>
<html>

<head>
    <script src="https://working-extension-excel.vercel.app/lib/tableau.extensions.1.latest.js"></script>
    <script src="https://working-extension-excel.vercel.app/lib/Sortable.min.js"></script>
    <title>Pivot Table Configuration</title>
    <style>
        :root {
            --primary-blue: #0056b3;
            /* Epsilon Blue */
            --primary-blue-dark: #003d7e;
            /* Darker Epsilon Blue for hover */
            --light-grey-bg: #f0f2f5;
            --white-card-bg: #ffffff;
            --border-color-light: #e0e0e0;
            /* Lighter border for general elements */
            --border-color-medium: #d1d7dc;
            /* Medium border for inputs/sections */
            --text-color: #333333;
            --label-color: #555555;
            --shadow-light: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-medium: 0 6px 16px rgba(0, 0, 0, 0.12);
            --shadow-subtle: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            margin: 0;
            /* Remove default margin */
            padding: 20px;
            /* Add consistent padding around content */
            background: var(--light-grey-bg);
            color: var(--text-color);
            line-height: 1.6;
            box-sizing: border-box;
            /* Include padding in element's total width and height */
        }

        /* --- Header Styles (from previous update, integrated for consistency) --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            /* Consistent padding */
            border-bottom: 1px solid var(--border-color-light);
            background-color: var(--white-card-bg);
            margin-bottom: 25px;
            /* Space below header */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            /* Subtle shadow for header */
            border-radius: 8px;
            /* Consistent border-radius */
        }

        header img {
            height: 45px;
            /* Slightly larger logo */
            display: block;
            /* Ensures no extra space below image */
        }

        header h1 {
            margin: 0;
            font-size: 26px;
            /* Slightly larger title */
            color: var(--primary-blue-dark);
            /* Use a darker blue for the title */
            font-weight: 700;
        }

        /* --- Main Config Panel Container --- */
        #config-panel {
            background: var(--white-card-bg);
            padding: 30px;
            /* More padding */
            border-radius: 12px;
            /* More rounded corners */
            box-shadow: var(--shadow-light);
            /* Modern shadow */
            /* Removed explicit border: 1px solid #808080; - shadow handles separation */
            margin-bottom: 20px;
            display: grid;
            /* Use grid for better layout of sections */
            grid-template-columns: 1fr;
            /* Single column layout for sections */
            gap: 25px;
            /* Space between sections */
        }

        /* --- Individual Configuration Sections --- */
        .config-section {
            margin-bottom: 0;
            /* Managed by grid gap in #config-panel */
            border: 1px solid var(--border-color-medium);
            /* Light border */
            padding: 20px;
            /* More padding */
            border-radius: 8px;
            /* Consistent border-radius */
            background: var(--white-card-bg);
            box-shadow: var(--shadow-subtle);
            /* Lighter shadow for inner sections */
        }

        h2,
        h3 {
            color: var(--primary-blue);
            margin-top: 0;
            margin-bottom: 15px;
            font-weight: 600;
        }

        label {
            display: block;
            /* Make labels block-level for better spacing */
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--label-color);
            font-size: 0.95em;
        }

        /* --- General Input Field Styles --- */
        input[type="text"],
        input[type="number"],
        select {
            /* Combined styles for most inputs and selects */
            width: calc(100% - 20px);
            /* Account for padding */
            padding: 10px;
            margin-bottom: 15px;
            /* Space below inputs */
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            font-size: 1em;
            color: var(--text-color);
            background-color: var(--white-card-bg);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            box-sizing: border-box;
            /* Include padding in width */
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(0, 86, 179, 0.2);
            /* Focus ring effect */
        }

        /* Specific styling for select dropdown */
        select {
            appearance: none;
            /* Remove default dropdown arrow */
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="%23555555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 30px;
            /* Space for custom arrow */
        }

        input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.1);
            /* Slightly larger checkbox */
        }

        /* --- Button Styles --- */
        button {
            background: var(--primary-blue);
            color: white;
            padding: 12px 24px;
            /* More padding for a softer button */
            border: none;
            /* Removed explicit border */
            border-radius: 8px;
            /* More rounded corners */
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: var(--shadow-light);
            /* Subtle shadow for buttons */
            margin: 5px;
            /* Keep existing margin for spacing */
        }

        button:hover {
            background: var(--primary-blue-dark);
            transform: translateY(-2px);
            /* Slight lift effect */
            box-shadow: var(--shadow-medium);
            /* More pronounced shadow on hover */
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* --- Sortable Lists --- */
        .sortable-list {
            min-height: 40px;
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            /* Consistent border-radius */
            padding: 10px;
            margin: 10px 0;
            background: var(--white-card-bg);
            overflow: auto;
            /* Ensure scrollability */
        }

        .sortable-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: var(--light-grey-bg);
            border: 1px solid var(--border-color-light);
            border-radius: 4px;
            /* Consistent border-radius */
            cursor: grab;
            /* More indicative cursor */
            font-size: 0.95em;
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }

        .sortable-item:hover {
            background: #e9eef2;
            /* Slightly darker hover */
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
        }

        /* --- Column Selection (multi-select) --- */
        .columns-select {
            width: 100%;
            height: 150px;
            /* Increased height for better visibility */
            margin: 10px 0 20px 0;
            /* Add bottom margin */
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            background: var(--white-card-bg);
            overflow-y: auto;
            /* Ensure scroll if content overflows */
        }

        .columns-select option {
            padding: 8px 10px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .columns-select option:hover {
            background-color: var(--light-grey-bg);
        }

        .columns-select option:checked {
            background-color: var(--primary-blue);
            color: white;
        }

        /* --- Header Rows Control --- */
        .header-rows-control {
            margin-bottom: 15px;
            padding: 15px;
            /* More padding */
            border: 1px solid var(--border-color-medium);
            border-radius: 8px;
            /* Consistent border-radius */
            background: var(--light-grey-bg);
            /* Slightly different background for distinction */
        }

        .header-row-item {
            display: flex;
            align-items: center;
            background: var(--white-card-bg);
            /* White background for individual items */
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color-light);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            /* Subtle shadow */
        }

        .header-row-item:last-child {
            margin-bottom: 0;
            /* No margin on last item */
        }

        .header-row-item select,
        .header-row-item input[type="text"],
        .header-row-item input[type="color"] {
            margin-bottom: 0;
            /* Remove bottom margin for inline elements */
            flex-grow: 1;
            /* Allow them to take available space */
            margin-right: 10px;
            /* Space between elements */
        }

        .header-row-item button {
            margin-top: 0;
            /* No top margin */
            padding: 8px 15px;
            /* Adjust button padding */
            font-size: 0.9em;
            white-space: nowrap;
        }

        .remove-btn {
            background: #dc3545 !important;
            /* Red for remove button */
            box-shadow: none !important;
            /* Remove shadow for smaller button */
        }

        .remove-btn:hover {
            background: #c82333 !important;
            transform: none !important;
            /* No lift effect for remove */
            box-shadow: none !important;
        }

        /* --- Format Settings Modal --- */
        .format-settings {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white-card-bg);
            padding: 30px;
            /* More padding */
            border-radius: 12px;
            /* Consistent border-radius */
            box-shadow: var(--shadow-medium);
            /* Stronger shadow for modal */
            z-index: 1000;
            border: 1px solid var(--border-color-medium);
            /* Light border */
            width: 450px;
            /* Adjusted width */
            max-width: 90%;
            /* Responsive consideration */
        }

        .format-tabs {
            display: flex;
            margin-bottom: 20px;
            /* More space below tabs */
            border-bottom: 1px solid var(--border-color-light);
        }

        .format-tab {
            padding: 12px 15px;
            /* More padding */
            cursor: pointer;
            border-bottom: 3px solid transparent;
            /* Thicker active indicator */
            font-weight: 500;
            color: var(--label-color);
            transition: color 0.2s ease, border-color 0.2s ease;
        }

        .format-tab:hover {
            color: var(--primary-blue);
        }

        .format-tab.active {
            border-color: var(--primary-blue);
            /* Active tab color */
            color: var(--primary-blue-dark);
            font-weight: 600;
        }

        .format-content {
            display: none;
        }

        .format-content.active {
            display: block;
        }

        .color-picker,
        .alignment-control {
            display: flex;
            align-items: center;
            margin: 15px 0;
            /* More margin */
            gap: 15px;
            /* More gap */
        }

        .condition-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
            gap: 10px;
            /* Gap for wrapped items */
        }

        .condition-row select,
        .condition-row input[type="text"] {
            width: auto;
            /* Allow auto width */
            margin: 0;
            /* Remove margins if gap is used */
            flex-grow: 1;
            /* Allow flex growth */
        }

        /* --- Title Section --- */
        .title-section {
            margin-bottom: 25px;
            /* More margin */
        }

        .title-control {
            margin: 15px 0;
            /* More margin */
            display: flex;
            align-items: center;
            gap: 15px;
            /* More gap */
            flex-wrap: wrap;
            /* Allow wrapping */
        }

        .title-control label {
            width: 120px;
            flex-shrink: 0;
            /* Prevent shrinking */
            margin-bottom: 0;
            /* No bottom margin if inline */
        }

        .title-control input[type="text"] {
            flex: 1;
            padding: 8px;
            /* Slightly less padding to fit better */
            min-width: 150px;
            /* Minimum width for input */
        }

        .title-control select {
            width: 200px;
            /* Fixed width for select */
            min-width: 150px;
        }

        .title-color-controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            /* More gap */
            flex-wrap: wrap;
        }

        .title-color-picker {
            display: flex;
            align-items: center;
            gap: 8px;
            /* More gap */
        }

        input[type="color"] {
            width: 35px;
            /* Slightly larger color picker */
            height: 35px;
            padding: 3px;
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            /* Consistent border-radius */
            cursor: pointer;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
            /* Slightly rounded swatch */
        }

        /* --- Rename Modal --- */
        .rename-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--white-card-bg);
            padding: 30px;
            /* More padding */
            border-radius: 12px;
            box-shadow: var(--shadow-medium);
            z-index: 1000;
            width: 450px;
            /* Adjusted width */
            max-height: 85vh;
            /* Allow more height */
            overflow-y: auto;
            border: 1px solid var(--border-color-medium);
        }

        .rename-modal h3 {
            margin-bottom: 20px;
        }

        .rename-field {
            display: flex;
            align-items: center;
            margin: 12px 0;
            /* More margin */
        }

        .rename-field label {
            width: 140px;
            /* More width for label */
            margin-right: 15px;
            /* More margin */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            /* Prevent wrapping */
            font-size: 0.9em;
        }

        .rename-field input {
            flex: 1;
            padding: 8px;
            /* Consistent padding */
        }

        /* --- Table Preview Styles (if used in config.html) --- */
        table {
            border-collapse: separate;
            /* Use separate to allow border-radius on cells if needed */
            border-spacing: 0;
            /* Remove space between cells */
            width: 100%;
            margin-top: 25px;
            /* More space above table */
            background: var(--white-card-bg);
            border: 1px solid var(--border-color-medium);
            /* Single border for table */
            border-radius: 8px;
            /* Rounded corners for table */
            overflow: hidden;
            /* Ensures content respects border-radius */
        }

        th,
        td {
            border: 1px solid var(--border-color-light);
            /* Lighter cell borders */
            padding: 12px 15px;
            /* More padding */
            vertical-align: middle;
            text-align: left;
            /* Default text align */
        }

        th {
            background-color: #e9ecef;
            /* Light grey for headers */
            font-weight: 600;
            color: var(--text-color);
        }

        tr:nth-child(even) {
            background-color: #fcfcfc;
            /* Subtle striping */
        }

        tr:hover td {
            background-color: #f5f5f5;
            /* Light hover effect on rows */
        }

        .group-header {
            background-color: #e9ecef;
            /* Consistent with header background */
            font-weight: bold;
        }

        .table-title {
            vertical-align: middle !important;
            font-size: 1.2em;
            font-weight: bold;
        }

        .grand-total {
            background-color: #dee2e6;
            /* Slightly darker for grand totals */
            font-weight: bold;
        }

        .subtotal-row {
            background-color: #f8f9fa !important;
            /* Light background for subtotals */
            border-top: 2px solid var(--border-color-medium) !important;
            /* Stronger top border */
        }

        .subtotal-row td {
            font-weight: 600 !important;
        }

        .subtotal {
            background-color: #e9ecef !important;
            /* Consistent with other neutral backgrounds */
        }

        .subtotal-row td.grand-total {
            background-color: inherit !important;
            /* Inherit to avoid double background */
            font-weight: bold !important;
        }

        /* --- Bottom Button Group --- */
        .button-group {
            /* Assuming this is for Save/Cancel buttons */
            display: flex;
            justify-content: flex-end;
            /* Align to the right */
            gap: 15px;
            /* Space between buttons */
            margin-top: 25px;
            /* More space above button group */
            padding-top: 20px;
            border-top: 1px solid var(--border-color-light);
            /* Separator line */
        }

        /* Specific button overrides for save/cancel if they have specific classes */
        .save-config {
            /* If you have a specific class for save button */
            background: var(--primary-blue) !important;
            /* Ensure it's Epsilon blue */
        }

        .save-config:hover {
            background: var(--primary-blue-dark) !important;
        }

        .cancel-config {
            /* Example for a cancel button */
            background: #6c757d !important;
            /* A neutral grey */
        }

        .cancel-config:hover {
            background: #5a6268 !important;
        }

        #filter-list {
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            padding: 10px;
            background: var(--white-card-bg);
        }

        #filter-list div {
            padding: 5px 0;
            display: flex;
            align-items: center;
        }

        #filter-list input[type="checkbox"] {
            margin-right: 8px;
        }

        #filter-list label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }

        /* --- NEW METRIC GROUPING STYLES --- */
        .metric-groups-section {
            border: 2px solid var(--primary-blue);
            background: linear-gradient(135deg, #f8fafe, #ffffff);
        }

        .group-management {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--light-grey-bg);
            border-radius: 8px;
        }

        .group-management h4 {
            margin: 0;
            color: var(--primary-blue);
            font-size: 1.1em;
        }

        .add-group-btn {
            background: #28a745;
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .add-group-btn:hover {
            background: #218838;
        }

        .metric-group {
            border: 1px solid var(--border-color-medium);
            border-radius: 8px;
            margin-bottom: 15px;
            background: var(--white-card-bg);
            box-shadow: var(--shadow-subtle);
        }

        .metric-group-header {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(135deg, #f1f3f4, #e8eaf6);
            border-bottom: 1px solid var(--border-color-light);
            cursor: pointer;
            border-radius: 8px 8px 0 0;
        }

        .metric-group-header:hover {
            background: linear-gradient(135deg, #e8eaf6, #c5cae9);
        }

        .group-name-input {
            flex: 1;
            border: none;
            background: transparent;
            font-weight: 600;
            color: var(--primary-blue);
            font-size: 1em;
            padding: 4px 8px;
            border-radius: 4px;
            margin-right: 10px;
        }

        .group-name-input:focus {
            background: white;
            border: 1px solid var(--primary-blue);
            outline: none;
        }

        .group-actions {
            display: flex;
            gap: 8px;
        }

        .group-toggle {
            background: none;
            border: none;
            color: var(--primary-blue);
            cursor: pointer;
            padding: 4px;
            margin: 0;
            transform: none;
            box-shadow: none;
            font-size: 1.2em;
            transition: transform 0.3s ease;
        }

        .group-toggle:hover {
            background: rgba(0, 86, 179, 0.1);
            transform: scale(1.1);
        }

        .group-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .delete-group-btn {
            background: #dc3545;
            padding: 4px 8px;
            font-size: 0.8em;
            margin: 0;
        }

        .delete-group-btn:hover {
            background: #c82333;
        }

        .metric-group-content {
            padding: 15px;
            display: block;
            transition: all 0.3s ease;
        }

        .metric-group-content.collapsed {
            display: none;
        }

        .group-field-selection {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .available-fields,
        .assigned-fields {
            flex: 1;
        }

        .available-fields h5,
        .assigned-fields h5 {
            margin: 0 0 10px 0;
            color: var(--label-color);
            font-size: 0.95em;
            font-weight: 600;
        }

        .field-select {
            width: 100%;
            height: 100px;
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            padding: 8px;
            background: var(--white-card-bg);
            font-size: 0.9em;
        }

        .field-select option {
            padding: 4px;
        }

        .transfer-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-self: center;
            margin: 0 10px;
        }

        .transfer-btn {
            background: var(--primary-blue);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            margin: 0;
            min-width: 50px;
        }

        .transfer-btn:hover {
            background: var(--primary-blue-dark);
        }

        .transfer-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .assigned-fields-list {
            min-height: 100px;
            border: 1px solid var(--border-color-medium);
            border-radius: 6px;
            padding: 8px;
            background: var(--light-grey-bg);
        }

        .assigned-field-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin: 4px 0;
            background: var(--white-card-bg);
            border: 1px solid var(--border-color-light);
            border-radius: 4px;
            font-size: 0.9em;
        }

        .assigned-field-item:hover {
            background: #f0f4f8;
        }

        .remove-field-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.7em;
            margin: 0;
        }

        .remove-field-btn:hover {
            background: #c82333;
        }

        .no-groups-message {
            text-align: center;
            padding: 40px 20px;
            color: var(--label-color);
            font-style: italic;
            background: var(--light-grey-bg);
            border-radius: 8px;
            border: 2px dashed var(--border-color-medium);
        }

        /* Hierarchical table headers for preview */
        .hierarchical-header th[colspan] {
            background: linear-gradient(135deg, var(--primary-blue), var(--primary-blue-dark));
            color: white;
            font-weight: 600;
            text-align: center;
            font-size: 1.05em;
        }

        .hierarchical-header th.metric-group-header-cell {
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: white;
            font-weight: 700;
            text-transform: none;
            /* ‚Üê ADD THIS LINE */
        }

        .metric-subheader th {
            background: linear-gradient(135deg, #718096, #4a5568);
            color: white;
            font-weight: 500;
            font-size: 0.9em;
        }

        /* Export Mode Styles */
        .config-section.mode-disabled {
            opacity: 0.5;
            pointer-events: none;
            position: relative;
        }

        .config-section.mode-disabled::before {
            content: "Available in Formatted Excel mode only";
            position: absolute;
            top: 10px;
            right: 15px;
            background: #6c757d;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 10;
        }

        .export-mode-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: 500;
            margin-left: 10px;
        }

        .mode-formatted {
            background: #d4edda;
            color: #155724;
        }

        .mode-datadump {
            background: #cce5ff;
            color: #004085;

            .mode-datadump .pivot-btn,
            .mode-datadump .value-btn {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <header
        style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; border-bottom: 1px solid #e0e0e0; background-color: #f8f9fa;">
        <div style="flex: 1; text-align: left;">
            <img src="https://www.epsilon.com/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Feps-logo-2023_v03--blue.3488a4b3.svg&w=256&q=75"
                alt="Epsilon Logo" style="height: 40px;">
        </div>
        <div style="flex: 2; text-align: center;">
            <h1 style="margin: 0; font-size: 24px; color: #333;">Excel Report Downloader</h1>
        </div>
        <div style="flex: 1; display: flex; justify-content: flex-end; align-items: center;">
            <a href="mailto:abhishek.rao@epsilon.com" style="text-decoration: none; color: var(--primary-blue);">
                <img src="images/icons8-email-100.png" alt="Email" style="height: 50px;">
            </a>
        </div>
        </div>
    </header>

    <div id="config-panel">
        <div class="config-section">
            <h3>Select Worksheet</h3>
            <select id="worksheet-select">
                <option value="">Select a worksheet</option>
            </select>
        </div>

        <div class="config-section">
            <h3>Export Mode</h3>
            <div style="display: flex; gap: 20px; align-items: center; margin: 15px 0;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="export-mode" value="formatted" checked style="margin-right: 8px;">
                    <span style="font-weight: 600;"><img src="images/icons8-excel-48.png" alt="Chart"
                            style="height: 16px; margin-right: 4px;vertical-align: middle;"> Formatted Excel</span>
                    <small style="display: block; color: #666; margin-left: 20px;">Full pivot table with formatting,
                        totals, and grouping</small>
                </label>
            </div>
            <div style="display: flex; gap: 20px; align-items: center; margin: 15px 0;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="export-mode" value="datadump" style="margin-right: 8px;">
                    <span style="font-weight: 600;"><img src="images/icons8-csv-48.png" alt="Chart"
                            style="height: 16px; margin-right: 4px;vertical-align: middle;"> Data Dump</span>
                    <small style="display: block; color: #666; margin-left: 20px;">Raw data export with custom headers
                        only</small>
                </label>
            </div>
        </div>

        <div class="config-section">
            <h3>File Settings</h3>
            <div class="title-control">
                <label id="file-name-label">Excel File Name:</label>
                <input type="text" id="workbook-file-name" placeholder="Enter file name" value="pivot_data">
                <span>OR</span>
                <select id="excel-file-name-field">
                    <option value="">None</option>
                </select>
            </div>
            <div class="export-mode-hint" id="file-name-hint" style="font-size: 0.9em; color: #666; margin-top: 5px;">
                This name will be used for the Excel file.
            </div>
        </div>

        <div class="config-section">
            <h3>Sheet Settings</h3>
            <div class="title-control">
                <label>Sheet Name:</label>
                <input type="text" id="sheet-name" placeholder="Enter sheet name">
                <span>OR</span>
                <select id="sheet-name-field">
                    <option value="">Select field for sheet name</option>
                </select>
            </div>
        </div>

        <div class="config-section">
            <h3>Header Rows</h3>
            <div class="header-rows-control">
                <label>Number of Header Rows:</label>
                <input type="number" id="header-rows-count" min="0" value="0" style="width: 60px;">
                <button onclick="applyHeaderRows()">Apply</button>
            </div>
        </div>

        <div class="config-section title-section">
            <h3>Table Title</h3>
            <input type="text" id="table-title" placeholder="Enter custom title">
            <span>OR</span>
            <select id="title-column">
                <option value="">Select column for title</option>
            </select>
            <div class="title-color-controls">
                <div class="alignment-control">
                    <label>Title Alignment:</label>
                    <select id="title-alignment">
                        <option value="left">Left</option>
                        <option value="center">Center</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                <div class="title-color-picker">
                    <label>Title Color:</label>
                    <input type="color" id="title-font-color" value="#000000">
                </div>
                <div class="title-color-picker">
                    <label>Title Background:</label>
                    <input type="color" id="title-bg-color" value="#F8F9FA">
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Available Columns</h3>
            <select id="available-columns" class="columns-select" multiple></select>
            <div class="button-group">
                <button onclick="addToSection('group')">Add to Rows</button>
                <button onclick="addToSection('pivot')" class="pivot-btn">Add to Columns</button>
                <button onclick="addToSection('value')" class="value-btn">Add to Values</button>
            </div>
        </div>

        <!-- NEW METRIC GROUPS SECTION -->
        <div class="config-section metric-groups-section">
            <div class="group-management">
                <h4><img src="images/icons8-genealogy-50.png" alt="Chart"
                        style="height: 16px; margin-right: 4px; vertical-align: middle;"> Metric Grouping</h4>
                <button class="add-group-btn" onclick="addMetricGroup()">+ Add Group</button>
            </div>

            <div id="metric-groups-container">
                <div class="no-groups-message" id="no-groups-message">
                    <p>No metric groups created yet.</p>
                    <p>Click "Add Group" to create hierarchical groupings for your value fields.</p>
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Subtotal Levels</h3>
            <select id="subtotal-level-select" multiple style="width: 100%; height: 80px;">
                <option value="0">Group Level 1</option>
                <option value="1">Group Level 2</option>
                <option value="2">Group Level 3</option>
            </select>
            <p>Select one or more group levels to show subtotals.</p>

            <!-- PATCH: Add subtotal renaming section -->
            <div style="margin-top: 15px;">
                <h4>Subtotal Label Customization</h4>
                <div id="subtotal-labels-container">
                    <!-- Dynamic subtotal label inputs will be added here -->
                </div>
                <div style="margin-top: 10px;">
                    <label>
                        <input type="checkbox" id="use-custom-subtotal-labels" onchange="toggleSubtotalLabels()">
                        Use custom subtotal labels
                    </label>
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Totals</h3>
            <label><input type="checkbox" id="show-subtotals"> Row Subtotals</label>
            <label><input type="checkbox" id="show-row-totals"> Row Grand Totals</label>
            &nbsp;
            <input type="text" id="rowTotalsLabel" placeholder="Row Totals Label" style="width: 150px;" />
            <label><input type="checkbox" id="show-column-totals"> Column Grand Totals</label>
            &nbsp;
            <input type="text" id="columnTotalsLabel" placeholder="Column Totals Label" style="width: 150px;" />
        </div>

        <div class="config-section">
            <h3>Row Groups</h3>
            <div id="group-columns" class="sortable-list"></div>
        </div>

        <div class="config-section">
            <h3>Row Formatting Rules</h3>
            <div class="header-rows-control">
                <label>Format rows based on:</label>
                <select id="row-format-field">
                    <option value="">Select a field</option>
                    <!-- Will be populated dynamically -->
                </select>
            </div>

            <div id="row-format-rules" style="margin-top: 15px;">
                <div class="header-row-item">
                    <select class="format-value-select">
                        <option value="">Select value</option>
                    </select>
                    <div class="title-color-picker">
                        <label>Row Color:</label>
                        <input type="color" class="row-format-color" value="#FFFFFF">
                    </div>
                    <button onclick="addRowFormatRule()">Add Rule</button>
                </div>
            </div>
        </div>

        <div class="config-section">
            <h3>Column Groups</h3>
            <div id="pivot-columns" class="sortable-list"></div>
        </div>

        <div class="config-section">
            <h3>Values</h3>
            <div id="value-columns" class="sortable-list"></div>
        </div>


        <div class="button-group">
            <button onclick="showRenameModal()">Rename Fields</button>
            <button onclick="showHeaderFormatModal()">Format Headers</button>
            <button id="generate-btn">Generate Pivot Table</button>
            <button id="save-btn" class="save-config">Save Configuration</button>
        </div>
    </div>
    <div id="data-container"></div>

    <div id="format-settings" class="format-settings">
        <div class="format-tabs">
            <div class="format-tab active" onclick="showFormatTab('basic')">Basic</div>
            <div class="format-tab" onclick="showFormatTab('conditional')">Conditional</div>
            <div style="flex:1"></div>
            <button onclick="closeFormatSettings()">√ó</button>
        </div>

        <div id="basic-format" class="format-content active">
            <div class="color-picker" id="number-format-container">
                <label>Number Format:</label>
                <select id="format-type">
                    <option value="text">Text</option>
                    <option value="number">Number</option>
                    <option value="currency">Currency</option>
                    <option value="percentage">Percentage</option>`r`n <option value="date">Date</option>
                </select>
            </div>

            <div class="color-picker" id="date-format-container" style="display: none;">`r`n <label>Date
                    Format:</label>`r`n <input type="text" id="date-format" placeholder="e.g. MM/DD/YYYY"
                    value="MM/DD/YYYY">`r`n <small style="display:block; color:#666; margin-top:5px;">Use MM, DD, YYYY,
                    MMM, etc.</small>`r`n </div>`r`n`r`n <div class="color-picker" id="currency-symbol-container"
                style="display: none;">
                <label>Currency Symbol:</label>
                <input type="text" id="currency-symbol" class="currency-symbol-input" value="$" maxlength="3">
            </div>
            <div class="color-picker" id="decimals-container">
                <label>Decimal Places:</label>
                <input type="number" id="decimals" min="0" max="4" value="2">
            </div>
            <div class="color-picker">
                <label>Font Color:</label>
                <input type="color" id="font-color" value="#000000">
            </div>
            <div class="color-picker">
                <label>Background Color:</label>
                <input type="color" id="bg-color" value="#FFFFFF">
            </div>
        </div>

        <div id="conditional-format" class="format-content">
            <div id="conditions-container"></div>
            <button onclick="addNewCondition()">+ Add Condition</button>
        </div>

        <div style="margin-top: 20px;">
            <button onclick="saveFormatSettings()">Save</button>
            <button onclick="closeFormatSettings()">Cancel</button>
        </div>
    </div>

    <div id="rename-modal" class="rename-modal">
        <h3>Rename Fields</h3>
        <div id="rename-fields-list"></div>
        <div style="margin-top: 20px;">
            <button onclick="saveRenames()">Save Changes</button>
            <button onclick="closeRenameModal()">Cancel</button>
        </div>
    </div>

    <div id="header-format-modal" class="format-settings">
        <div class="format-tabs">
            <div class="format-tab active" onclick="showHeaderFormatTab('row-groups')">Row Groups</div>
            <div class="format-tab" onclick="showHeaderFormatTab('column-groups')">Column Groups</div>
            <div class="format-tab" onclick="showHeaderFormatTab('totals')">Totals</div>
            <div class="format-tab" onclick="showHeaderFormatTab('subtotals')">Subtotals</div>
            <div style="flex:1"></div>
            <button onclick="closeHeaderFormatModal()">√ó</button>
        </div>

        <div id="subtotals-format" class="format-content">
            <div class="color-picker">
                <label>Font Color:</label>
                <input type="color" id="subtotals-font-color" value="#000000">
            </div>
            <div class="color-picker">
                <label>Background Color:</label>
                <input type="color" id="subtotals-bg-color" value="#F8F9FA">
            </div>
            <div class="alignment-control">
                <label>Text Alignment:</label>
                <select id="subtotals-alignment">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                </select>
            </div>
        </div>

        <div id="row-groups-format" class="format-content active">
            <div class="color-picker">
                <label>Font Color:</label>
                <input type="color" id="row-group-font-color" value="#000000">
            </div>
            <div class="color-picker">
                <label>Background Color:</label>
                <input type="color" id="row-group-bg-color" value="#F1F3F5">
            </div>
            <div class="alignment-control">
                <label>Text Alignment:</label>
                <select id="row-group-alignment">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                </select>
            </div>
        </div>

        <div id="column-groups-format" class="format-content">
            <div class="color-picker">
                <label>Font Color:</label>
                <input type="color" id="column-group-font-color" value="#000000">
            </div>
            <div class="color-picker">
                <label>Background Color:</label>
                <input type="color" id="column-group-bg-color" value="#E9ECEF">
            </div>
            <div class="alignment-control">
                <label>Text Alignment:</label>
                <select id="column-group-alignment">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                </select>
            </div>
        </div>

        <div id="totals-format" class="format-content">
            <div class="color-picker">
                <label>Font Color:</label>
                <input type="color" id="totals-font-color" value="#000000">
            </div>
            <div class="color-picker">
                <label>Background Color:</label>
                <input type="color" id="totals-bg-color" value="#E9ECEF">
            </div>
            <div class="alignment-control">
                <label>Text Alignment:</label>
                <select id="totals-alignment">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                </select>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button onclick="saveHeaderFormatSettings()">Save</button>
            <button onclick="closeHeaderFormatModal()">Cancel</button>
        </div>
    </div>

    <div id="header-row-modal" class="format-settings">
        <h3>Header Row Configuration</h3>
        <div class="header-row-config">
            <input type="hidden" id="current-header-row-index" value="-1">
            <div>
                <label>Header Content Type:</label>
                <select id="header-row-type" onchange="updateHeaderRowInputs()">
                    <option value="text">Custom Text</option>
                    <option value="column">Column Value</option>
                    <option value="filters">Filter Values</option>
                    <option value="refreshDate">Refresh Date</option>
                </select>
            </div>
            <div id="filter-selection-container">
                <label>Select Filters to Display:</label>
                <div id="filter-list" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div>
            </div>
            <div id="refreshDate-options" style="display:none; margin-top:0.5em;">
                <label>
                    <label>
                        Time Zone:
                        <select id="refresh-timezone" style="width:12em;">
                            <option>Loading‚Ä¶</option>
                        </select>
                    </label>
                    <br />
                    <label>
                        Date Format:
                        <select id="refresh-format" style="width:25em;">
                            <!-- Numeric Formats -->
                            <optgroup label="üìÖ Numeric Formats">
                                <option value='{"month":"2-digit","day":"2-digit","year":"numeric"}'>MM/DD/YYYY (e.g.
                                    12/25/2024)</option>
                                <option value='{"day":"2-digit","month":"2-digit","year":"numeric"}'>DD/MM/YYYY (e.g.
                                    25/12/2024)</option>
                                <option value='{"year":"numeric","month":"2-digit","day":"2-digit"}'>YYYY/MM/DD (e.g.
                                    2024/12/25)</option>
                                <option
                                    value='{"month":"2-digit","day":"2-digit","year":"numeric","formatStyle":"dash"}'>
                                    MM-DD-YYYY (e.g. 12-25-2024)</option>
                                <option
                                    value='{"day":"2-digit","month":"2-digit","year":"numeric","formatStyle":"dash"}'>
                                    DD-MM-YYYY (e.g. 25-12-2024)</option>
                                <option
                                    value='{"year":"numeric","month":"2-digit","day":"2-digit","formatStyle":"dash"}'>
                                    YYYY-MM-DD (e.g. 2024-12-25)</option>
                                <option
                                    value='{"month":"2-digit","day":"2-digit","year":"numeric","formatStyle":"dot"}'>
                                    MM.DD.YYYY (e.g. 12.25.2024)</option>
                                <option
                                    value='{"day":"2-digit","month":"2-digit","year":"numeric","formatStyle":"dot"}'>
                                    DD.MM.YYYY (e.g. 25.12.2024)</option>
                                <option
                                    value='{"year":"numeric","month":"2-digit","day":"2-digit","formatStyle":"dot"}'>
                                    YYYY.MM.DD (e.g. 2024.12.25)</option>
                            </optgroup>

                            <!-- Short Formats -->
                            <optgroup label="üìÜ Short Formats">
                                <option value='{"month":"numeric","day":"numeric","year":"2-digit"}'>M/D/YY (e.g.
                                    12/25/24)</option>
                                <option value='{"day":"numeric","month":"numeric","year":"2-digit"}'>D/M/YY (e.g.
                                    25/12/24)</option>
                                <option value='{"month":"2-digit","day":"2-digit","year":"2-digit"}'>MM/DD/YY (e.g.
                                    12/25/24)</option>
                                <option value='{"day":"2-digit","month":"2-digit","year":"2-digit"}'>DD/MM/YY (e.g.
                                    25/12/24)</option>
                                <option
                                    value='{"month":"2-digit","day":"2-digit","year":"2-digit","hour":"2-digit","minute":"2-digit","second":"2-digit","hour12":false}'>
                                    MM/DD/YY HH:mm:ss (e.g. 12/25/24 14:30:45)</option>
                            </optgroup>

                            <!-- Text-based Formats -->
                            <optgroup label="üìù Text-based Formats">
                                <option value='{"year":"numeric","month":"short","day":"numeric"}'>MMM DD, YYYY (e.g.
                                    Dec 25, 2024)</option>
                                <option value='{"day":"numeric","month":"short","year":"numeric"}'>DD MMM YYYY (e.g. 25
                                    Dec 2024)</option>
                                <option value='{"year":"numeric","month":"long","day":"numeric"}'>MMMM DD, YYYY (e.g.
                                    December 25, 2024)</option>
                                <option value='{"day":"numeric","month":"long","year":"numeric"}'>DD MMMM YYYY (e.g. 25
                                    December 2024)</option>
                                <option value='{"month":"short","day":"numeric"}'>MMM DD (e.g. Dec 25)</option>
                                <option value='{"month":"long","day":"numeric"}'>MMMM DD (e.g. December 25)</option>
                                <option value='{"month":"short","year":"numeric"}'>MMM YYYY (e.g. Dec 2024)</option>
                                <option value='{"month":"long","year":"numeric"}'>MMMM YYYY (e.g. December 2024)
                                </option>
                            </optgroup>

                            <!-- Day + Date Formats -->
                            <optgroup label="üóìÔ∏è Day + Date Formats">
                                <option value='{"weekday":"short","year":"numeric","month":"short","day":"numeric"}'>
                                    ddd, MMM DD, YYYY (e.g. Wed, Dec 25, 2024)</option>
                                <option value='{"weekday":"long","year":"numeric","month":"long","day":"numeric"}'>dddd,
                                    MMMM DD, YYYY (e.g. Wednesday, December 25, 2024)</option>
                                <option value='{"weekday":"short","day":"2-digit","month":"2-digit","year":"numeric"}'>
                                    ddd DD/MM/YYYY (e.g. Wed 25/12/2024)</option>
                                <option value='{"weekday":"long","day":"numeric","month":"long","year":"numeric"}'>dddd
                                    DD MMMM YYYY (e.g. Wednesday 25 December 2024)</option>
                            </optgroup>

                            <!-- Time + Date Formats -->
                            <optgroup label="üïê Time + Date Formats">
                                <option
                                    value='{"month":"2-digit","day":"2-digit","year":"numeric","hour":"2-digit","minute":"2-digit"}'>
                                    MM/DD/YYYY HH:mm (e.g. 12/25/2024 14:30)</option>
                                <option
                                    value='{"day":"2-digit","month":"2-digit","year":"numeric","hour":"2-digit","minute":"2-digit","second":"2-digit"}'>
                                    DD/MM/YYYY HH:mm:ss (e.g. 25/12/2024 14:30:45)</option>
                                <option
                                    value='{"year":"numeric","month":"2-digit","day":"2-digit","hour":"2-digit","minute":"2-digit","second":"2-digit"}'>
                                    YYYY-MM-DD HH:mm:ss (e.g. 2024-12-25 14:30:45)</option>
                                <option
                                    value='{"year":"numeric","month":"short","day":"numeric","hour":"2-digit","minute":"2-digit"}'>
                                    MMM DD, YYYY HH:mm (e.g. Dec 25, 2024 14:30)</option>
                                <option value='{"month":"short","day":"numeric","hour":"2-digit","minute":"2-digit"}'>
                                    MMM DD HH:mm (e.g. Dec 25 14:30)</option>
                            </optgroup>

                            <!-- 12-Hour Time Formats -->
                            <optgroup label="üïë 12-Hour Time Formats">
                                <option
                                    value='{"month":"2-digit","day":"2-digit","year":"numeric","hour":"numeric","minute":"2-digit","hour12":true}'>
                                    MM/DD/YYYY h:mm AM/PM (e.g. 12/25/2024 2:30 PM)</option>
                                <option
                                    value='{"year":"numeric","month":"short","day":"numeric","hour":"numeric","minute":"2-digit","hour12":true}'>
                                    MMM DD, YYYY h:mm AM/PM (e.g. Dec 25, 2024 2:30 PM)</option>
                                <option
                                    value='{"day":"2-digit","month":"2-digit","year":"numeric","hour":"numeric","minute":"2-digit","second":"2-digit","hour12":true}'>
                                    DD/MM/YYYY h:mm:ss AM/PM (e.g. 25/12/2024 2:30:45 PM)</option>
                            </optgroup>
                        </select>
                    </label>

                    <div style="margin-top:0.5em;">
                        <label>Custom Prefix:</label>
                        <input type="text" id="header-row-prefix" placeholder="e.g. As of ">
                    </div>
            </div>
            <div id="text-input-container">
                <label>Header Text:</label>
                <input type="text" id="header-row-text" placeholder="Enter header text">
            </div>
            <div id="column-select-container">
                <label>Select Column:</label>
                <select id="header-row-column">
                    <option value="">Select column for header</option>
                </select>
            </div>
            <div class="title-color-controls">
                <div class="alignment-control">
                    <label>Text Alignment:</label>
                    <select id="header-row-alignment">
                        <option value="left">Left</option>
                        <option value="center">Center</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                <div class="title-color-picker">
                    <label>Font Color:</label>
                    <input type="color" id="header-row-font-color" value="#000000">
                </div>
                <div class="title-color-picker">
                    <label>Background Color:</label>
                    <input type="color" id="header-row-bg-color" value="#F8F9FA">
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button onclick="saveHeaderRowConfig()">Save</button>
                <button onclick="closeHeaderRowModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let currentWorksheet = "";
        let allConfigs = {};
        let worksheetData = {};
        let allData = [];
        let columns = [];
        let sortables = {};
        let currentFormattingColumn = null;
        let formatSettings = {};
        let titleColumnMap = {};
        let tableTitle = '';
        let titleFontColor = '000000';
        let titleBgColor = 'F8F9FA';
        let titleAlignment = 'center';
        let fieldRenames = {};
        let headerRowsCount = 0;
        let headerRowSettings = [];
        let headerFormatSettings = {
            rowGroups: { fontColor: '000000', bgColor: 'F1F3F5', textAlign: 'left' },
            columnGroups: { fontColor: '000000', bgColor: 'E9ECEF', textAlign: 'center' },
            totals: { fontColor: '000000', bgColor: 'E9ECEF', textAlign: 'right' },
            subtotals: { fontColor: '000000', bgColor: 'F8F9FA', textAlign: 'left' }
        };
        let currentWorksheetName = '';
        let allFilters = [];
        let selectedFilters = [];

        // NEW METRIC GROUPING VARIABLES
        let metricGroups = [];
        let metricGroupIdCounter = 1;
        let exportMode = 'formatted'; // 'formatted' or 'datadump'
        // PATCH: Subtotal label customization variables
        let subtotalLabels = {}; // {level: customLabel}
        let useCustomSubtotalLabels = false;

        // Custom date formatter to handle different separators
        function formatDateWithCustomSeparator(date, formatOptions, timeZone) {
            // Handle custom format styles (dash, dot)
            const formatStyle = formatOptions.formatStyle;
            const cleanOptions = { ...formatOptions };
            delete cleanOptions.formatStyle; // Remove custom property

            if (timeZone) {
                cleanOptions.timeZone = timeZone;
            }

            // Get the formatted date
            let formattedDate = new Intl.DateTimeFormat(undefined, cleanOptions).format(date);

            // Apply custom separators
            if (formatStyle === 'dash') {
                formattedDate = formattedDate.replace(/\//g, '-');
            } else if (formatStyle === 'dot') {
                formattedDate = formattedDate.replace(/\//g, '.');
            }

            return formattedDate;
        }

        function switchExportModeQuiet(mode) {
            exportMode = mode;

            // Add/remove mode class on body for CSS targeting
            if (mode === 'datadump') {
                document.body.classList.add('mode-datadump');
                document.body.classList.remove('mode-formatted');
            } else {
                document.body.classList.add('mode-formatted');
                document.body.classList.remove('mode-datadump');
            }

            // Get all config sections that should be disabled in datadump mode
            const allConfigSections = document.querySelectorAll('.config-section');
            const sectionsToDisable = [];
            const sectionsToEnable = []; // Sections to specifically enable in datadump mode

            allConfigSections.forEach(section => {
                const h3 = section.querySelector('h3');
                if (h3) {
                    const title = h3.textContent.trim();

                    // These sections should be ENABLED in datadump mode
                    if (['Available Columns', 'Row Groups', 'Values'].includes(title) ||
                        title.includes('Metric Grouping')) {
                        sectionsToEnable.push(section);
                    }
                    // These sections should be DISABLED in datadump mode
                    else if (['Subtotal Levels', 'Totals',
                        'Row Formatting Rules', 'Column Groups'].includes(title)) {
                        sectionsToDisable.push(section);
                    }
                }
            });

            if (mode === 'datadump') {
                // Disable sections that aren't needed for datadump
                sectionsToDisable.forEach(section => {
                    section.classList.add('mode-disabled');
                });

                // Explicitly enable the sections we want for datadump
                sectionsToEnable.forEach(section => {
                    section.classList.remove('mode-disabled');
                    section.style.display = 'block';
                });

                // Update generate button text
                const generateBtn = document.getElementById('generate-btn');
                if (generateBtn) {
                    generateBtn.textContent = 'Generate Data Dump Preview';
                }
            } else {
                // In formatted mode, remove all disabled classes
                sectionsToDisable.forEach(section => {
                    section.classList.remove('mode-disabled');
                });

                sectionsToEnable.forEach(section => {
                    section.classList.remove('mode-disabled');
                });

                // Restore generate button text
                const generateBtn = document.getElementById('generate-btn');
                if (generateBtn) {
                    generateBtn.textContent = 'Generate Pivot Table';
                }
            }

            const fileNameLabel = document.getElementById('file-name-label');
            const fileNameHint = document.getElementById('file-name-hint');

            if (mode === 'datadump') {
                if (fileNameLabel) fileNameLabel.textContent = 'CSV Zip File Name:';
                if (fileNameHint) fileNameHint.textContent = 'This name will be used for the CSV zip file containing all data dumps.';
            } else {
                if (fileNameLabel) fileNameLabel.textContent = 'Excel File Name:';
                if (fileNameHint) fileNameHint.textContent = 'This name will be used for the Excel file.';
            }
        }


        function switchExportMode(mode) {
            // Use quiet mode switching for UI changes
            switchExportModeQuiet(mode);

            // Only trigger preview if data is available
            if (allData.length > 0) {
                if (mode === 'datadump') {
                    generateDataDumpPreview();
                } else {
                    generatePivotTable();
                }
            }
        }

        // Enhanced null handling for pivot data aggregation
        function parseValueForAggregation(value) {
            // Return null for actual null values, otherwise parse as number
            if (isNullValue(value)) {
                return null;
            }

            const cleaned = String(value).replace(/,/g, '');
            const parsed = parseFloat(cleaned);
            return isNaN(parsed) ? null : parsed;
        }

        function aggregateValues(existingValue, newValue) {
            // If both values are null, result is null
            if (existingValue === null && newValue === null) {
                return null;
            }

            // If one is null, use the other (treating null as "no contribution")
            if (existingValue === null) {
                return newValue;
            }
            if (newValue === null) {
                return existingValue;
            }

            // Both are numbers, add them
            return existingValue + newValue;
        }

        function populateTimeZones() {
            const tzSelect = document.getElementById('refresh-timezone');
            tzSelect.innerHTML = '';  // clear "Loading‚Ä¶"

            if (typeof Intl.supportedValuesOf === 'function') {
                Intl.supportedValuesOf('timeZone').forEach(zone => {
                    const opt = document.createElement('option');
                    opt.value = opt.textContent = zone;
                    tzSelect.appendChild(opt);
                });
            } else {
                // fallback list
                ['UTC', 'Asia/Kolkata', 'Asia/Dubai', 'America/New_York', 'Europe/London']
                    .forEach(zone => {
                        const opt = document.createElement('option');
                        opt.value = opt.textContent = zone;
                        tzSelect.appendChild(opt);
                    });
            }

            // set default to UTC
            tzSelect.value = 'UTC';
        }

        // Add to global variables
        let rowFormatSettings = {
            field: null,
            rules: {} // {value: bgColor}
        };

        // NEW METRIC GROUPING FUNCTIONS
        function addMetricGroup() {
            const group = {
                id: metricGroupIdCounter++,
                name: `Group ${metricGroups.length + 1}`,
                fields: [],
                collapsed: false
            };

            metricGroups.push(group);
            renderMetricGroups();
            updateNoGroupsMessage();
        }

        function removeMetricGroup(groupId) {
            const index = metricGroups.findIndex(g => g.id === groupId);
            if (index !== -1) {
                // Return fields to available columns
                const group = metricGroups[index];
                group.fields.forEach(fieldId => {
                    // Remove from value columns if it was there
                    const valueItem = document.querySelector(`#value-columns [data-id="${fieldId}"]`);
                    if (valueItem) {
                        valueItem.remove();
                    }
                });

                metricGroups.splice(index, 1);
                renderMetricGroups();
                updateNoGroupsMessage();
            }
        }

        function toggleMetricGroup(groupId) {
            const group = metricGroups.find(g => g.id === groupId);
            if (group) {
                group.collapsed = !group.collapsed;
                renderMetricGroups();
            }
        }

        function updateGroupName(groupId, newName) {
            const group = metricGroups.find(g => g.id === groupId);
            if (group) {
                group.name = newName;
            }
        }

        function addFieldToGroup(groupId, fieldId) {
            const group = metricGroups.find(g => g.id === groupId);
            if (group && !group.fields.includes(fieldId)) {
                group.fields.push(fieldId);
                renderMetricGroups();

                // Also add to value columns if not already there
                const existingItem = document.querySelector(`#value-columns [data-id="${fieldId}"]`);
                if (!existingItem) {
                    const fieldName = columns.find(c => c.id === fieldId)?.name || fieldId;
                    const item = document.createElement('div');
                    item.className = 'sortable-item';
                    item.dataset.id = fieldId;
                    item.innerHTML = `
                    <span>${fieldName}</span>
                    <button class="format-btn" onclick="openFormatSettings('${fieldId}')">‚öôÔ∏è</button>
                    <button class="remove-btn" onclick="removeFromSection('value', '${fieldId}')">√ó</button>
                `;
                    document.getElementById('value-columns').appendChild(item);
                }
            }
        }

        function removeFieldFromGroup(groupId, fieldId) {
            const group = metricGroups.find(g => g.id === groupId);
            if (group) {
                const index = group.fields.indexOf(fieldId);
                if (index !== -1) {
                    group.fields.splice(index, 1);
                    renderMetricGroups();
                }
            }
        }

        function renderMetricGroups() {
            const container = document.getElementById('metric-groups-container');

            if (metricGroups.length === 0) {
                container.innerHTML = `
                <div class="no-groups-message" id="no-groups-message">
                    <p>No metric groups created yet.</p>
                    <p>Click "Add Group" to create hierarchical groupings for your value fields.</p>
                </div>
            `;
                return;
            }

            container.innerHTML = metricGroups.map(group => `
            <div class="metric-group" data-group-id="${group.id}">
                <div class="metric-group-header" onclick="toggleMetricGroup(${group.id})">
                    <input type="text" class="group-name-input" 
                           value="${group.name}" 
                           onclick="event.stopPropagation()"
                           onchange="updateGroupName(${group.id}, this.value)"
                           onblur="updateGroupName(${group.id}, this.value)">
                    <div class="group-actions">
                        <button class="group-toggle ${group.collapsed ? 'collapsed' : ''}" 
                                onclick="event.stopPropagation(); toggleMetricGroup(${group.id})">
                            ‚ñº
                        </button>
                        <button class="delete-group-btn" 
                                onclick="event.stopPropagation(); removeMetricGroup(${group.id})">
                            √ó
                        </button>
                    </div>
                </div>
                <div class="metric-group-content ${group.collapsed ? 'collapsed' : ''}">
                    <div class="group-field-selection">
                        <div class="available-fields">
                            <h5>Available Fields</h5>
                            <select class="field-select" multiple size="6" onchange="updateTransferButtons(${group.id})">
                                ${getAvailableFieldsForGroup(group.id)}
                            </select>
                        </div>
                        <div class="transfer-buttons">
                            <button class="transfer-btn" onclick="transferFieldsToGroup(${group.id})" disabled>
                                ‚Üí
                            </button>
                            <button class="transfer-btn" onclick="transferFieldsFromGroup(${group.id})" disabled>
                                ‚Üê
                            </button>
                        </div>
                        <div class="assigned-fields">
                            <h5>Assigned Fields (${group.fields.length})</h5>
                            <div class="assigned-fields-list">
                                ${group.fields.map(fieldId => {
                const fieldName = columns.find(c => c.id === fieldId)?.name || fieldId;
                return `
                                        <div class="assigned-field-item" data-field-id="${fieldId}">
                                            <span>${fieldName}</span>
                                            <button class="remove-field-btn" onclick="removeFieldFromGroup(${group.id}, '${fieldId}')">√ó</button>
                                        </div>
                                    `;
            }).join('')}
                                ${group.fields.length === 0 ? '<div style="color: #999; font-style: italic; padding: 20px; text-align: center;">No fields assigned</div>' : ''}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `).join('');
        }

        function getAvailableFieldsForGroup(groupId) {
            const group = metricGroups.find(g => g.id === groupId);
            const assignedFields = group ? group.fields : [];

            // Get all fields assigned to other groups
            const fieldsInOtherGroups = metricGroups
                .filter(g => g.id !== groupId)
                .flatMap(g => g.fields);

            return columns
                .filter(col => !assignedFields.includes(col.id) && !fieldsInOtherGroups.includes(col.id))
                .map(col => `<option value="${col.id}">${col.name}</option>`)
                .join('');
        }

        function updateTransferButtons(groupId) {
            const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
            const availableSelect = groupElement.querySelector('.field-select');
            const assignedItems = groupElement.querySelectorAll('.assigned-field-item');

            const transferToBtn = groupElement.querySelector('.transfer-buttons .transfer-btn:first-child');
            const transferFromBtn = groupElement.querySelector('.transfer-buttons .transfer-btn:last-child');

            transferToBtn.disabled = availableSelect.selectedOptions.length === 0;
            transferFromBtn.disabled = assignedItems.length === 0;
        }

        function transferFieldsToGroup(groupId) {
            const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
            const availableSelect = groupElement.querySelector('.field-select');

            Array.from(availableSelect.selectedOptions).forEach(option => {
                addFieldToGroup(groupId, option.value);
            });
        }

        function transferFieldsFromGroup(groupId) {
            const group = metricGroups.find(g => g.id === groupId);
            if (group && group.fields.length > 0) {
                // Remove the last field (or you could make this more sophisticated)
                const lastField = group.fields[group.fields.length - 1];
                removeFieldFromGroup(groupId, lastField);

                // Also remove from value columns
                const valueItem = document.querySelector(`#value-columns [data-id="${lastField}"]`);
                if (valueItem) {
                    valueItem.remove();
                }
            }
        }

        function updateNoGroupsMessage() {
            const noGroupsMsg = document.getElementById('no-groups-message');
            if (noGroupsMsg) {
                noGroupsMsg.style.display = metricGroups.length === 0 ? 'block' : 'none';
            }
        }

        // PATCH: Subtotal label management functions
        function toggleSubtotalLabels() {
            useCustomSubtotalLabels = document.getElementById('use-custom-subtotal-labels').checked;
            const container = document.getElementById('subtotal-labels-container');

            if (useCustomSubtotalLabels) {
                updateSubtotalLabelsUI();
            } else {
                container.innerHTML = '';
            }
        }

        function updateSubtotalLabelsUI() {
            const container = document.getElementById('subtotal-labels-container');
            const selectedLevels = Array.from(document.getElementById('subtotal-level-select').selectedOptions)
                .map(opt => parseInt(opt.value));

            if (selectedLevels.length === 0 || !useCustomSubtotalLabels) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = '';

            selectedLevels.forEach(level => {
                const div = document.createElement('div');
                div.className = 'title-control';
                div.style.marginBottom = '10px';

                const groupCol = getConfig('group')[level];
                const levelName = groupCol ? (fieldRenames[groupCol.id] || groupCol.name) : `Level ${level + 1}`;

                div.innerHTML = `
                <label style="width: 150px;">Level ${level + 1} (${levelName}):</label>
                <input type="text" 
                       id="subtotal-label-${level}" 
                       placeholder="e.g., Total, Summary, Subtotal" 
                       value="${subtotalLabels[level] || ''}"
                       onchange="updateSubtotalLabel(${level}, this.value)"
                       style="flex: 1;">
                <small style="color: #666; margin-left: 10px; font-style: italic;">Shows only this text</small>
            `;

                container.appendChild(div);
            });
        }

        function updateSubtotalLabel(level, value) {
            if (value.trim()) {
                subtotalLabels[level] = value.trim();
            } else {
                delete subtotalLabels[level];
            }
        }

        // Add this function to populate the field selector
        function populateRowFormatFields() {
            const select = document.getElementById('row-format-field');
            select.innerHTML = '<option value="">Select a field</option>';

            columns.forEach(col => {
                const option = document.createElement('option');
                option.value = col.id;
                option.textContent = col.name;
                select.appendChild(option);
            });

            // Set saved value if exists
            if (rowFormatSettings.field) {
                select.value = rowFormatSettings.field;
                updateRowFormatValueSelector();
            }
        }

        // Update value selector based on selected field
        function updateRowFormatValueSelector() {
            const fieldId = document.getElementById('row-format-field').value;
            const valueSelect = document.querySelector('#row-format-rules .format-value-select');
            valueSelect.innerHTML = '<option value="">Select value</option>';

            if (!fieldId) return;

            // Get distinct values for this field
            const distinctValues = new Set();
            allData.forEach(row => {
                const val = row[fieldId];
                if (val !== null && val !== undefined) {
                    distinctValues.add(val.toString());
                }
            });

            // Add values to dropdown
            Array.from(distinctValues).sort().forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                option.textContent = val;
                valueSelect.appendChild(option);
            });
        }

        // Add a new formatting rule
        function addRowFormatRule() {
            const fieldId = document.getElementById('row-format-field').value;
            const valueSelect = document.querySelector('#row-format-rules .format-value-select');
            const colorInput = document.querySelector('#row-format-rules .row-format-color');

            if (!fieldId || !valueSelect.value) {
                alert("Please select both a field and a value");
                return;
            }

            // Save the rule
            rowFormatSettings.field = fieldId;
            rowFormatSettings.rules[valueSelect.value] = colorInput.value.replace('#', '');

            // Add visual representation
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'header-row-item';
            ruleDiv.innerHTML = `
            <span><strong>${valueSelect.value}</strong></span>
            <div style="background-color:${colorInput.value}; width: 20px; height: 20px; border: 1px solid #ccc;"></div>
            <button class="remove-btn" onclick="removeRowFormatRule('${valueSelect.value}')">√ó</button>
        `;

            document.getElementById('row-format-rules').appendChild(ruleDiv);

            // Reset inputs
            valueSelect.value = '';
            colorInput.value = '#FFFFFF';

            // Regenerate preview
            // generatePivotTable();
        }

        // Remove a formatting rule
        function removeRowFormatRule(value) {
            delete rowFormatSettings.rules[value];

            // Find and remove the visual element
            const rulesDiv = document.getElementById('row-format-rules');
            const ruleDivs = rulesDiv.querySelectorAll('.header-row-item');
            ruleDivs.forEach(div => {
                if (div.textContent.includes(value)) {
                    div.remove();
                }
            });

            // Regenerate preview
            // generatePivotTable();
        }

        async function initWorksheetSelector() {
            const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
            const select = document.getElementById('worksheet-select');
            select.innerHTML = '<option value="">Select a worksheet</option>';

            worksheets.forEach(ws => {
                const option = document.createElement('option');
                option.value = ws.name;
                option.textContent = ws.name;
                select.appendChild(option);
            });

            select.addEventListener('change', async (e) => {
                currentWorksheet = e.target.value;
                currentWorksheetName = e.target.value; // Make sure this line exists
                if (currentWorksheet) {
                    await fetchWorksheetData(currentWorksheet);
                    await loadConfiguration();
                }
            });
        }

        // 1. Enhanced null checking function
        function isNullValue(value) {
            if (value === null || value === undefined) return true;

            const strValue = String(value).toLowerCase().trim();
            return strValue === '' ||
                strValue === 'null' ||
                strValue === 'nulls' ||
                strValue === '%null%' ||
                strValue === '(null)' ||
                strValue === 'n/a' ||
                strValue === 'na';
        }

        // 2. Function to clean and display null values
        function cleanDisplayValue(value) {
            return isNullValue(value) ? '' : String(value);
        }

        async function fetchWorksheetData(worksheetName) {
            currentWorksheetName = worksheetName;
            if (worksheetData[worksheetName]) {
                allData = worksheetData[worksheetName].allData;
                columns = worksheetData[worksheetName].columns;
                populateAvailableColumns();
                updateSelects();
                renderMetricGroups();
                return;
            }

            const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                .find(ws => ws.name === worksheetName);

            if (!worksheet) {
                console.error(`Worksheet "${worksheetName}" not found`);
                return;
            }

            let dataTableReader = null;
            try {
                // Get column info first
                const columnsInfo = await worksheet.getSummaryColumnsInfoAsync();

                // Check if worksheet has any data
                if (!columnsInfo || columnsInfo.length === 0) {
                    console.warn(`Worksheet "${worksheetName}" has no columns`);
                    columns = [];
                    allData = [];
                    populateAvailableColumns();
                    updateSelects();
                    renderMetricGroups();
                    return;
                }

                // Get data reader
                dataTableReader = await worksheet.getSummaryDataReaderAsync();

                // Check if there are any pages
                if (dataTableReader.pageCount === 0) {
                    console.warn(`Worksheet "${worksheetName}" has no data pages`);
                    columns = columnsInfo.map(col => ({
                        id: col.fieldName,
                        name: col.fieldName.replace(/^\[.*?\]\.?/g, '')
                            .replace(/(SUM|AVG|COUNT)\(/gi, '')
                            .replace(/[^a-zA-Z0-9 ]/g, ' ')
                            .trim()
                    }));
                    allData = [];
                    worksheetData[worksheetName] = { allData, columns };
                    populateAvailableColumns();
                    updateSelects();
                    populateRowFormatFields();
                    renderMetricGroups();
                    return;
                }

                // Get the first page to understand column structure
                const firstPage = await dataTableReader.getPageAsync(0);
                const sortedColumns = firstPage.columns;

                // Create index mapping
                const indexMap = columnsInfo.map(viewCol =>
                    sortedColumns.findIndex(sortedCol => sortedCol.fieldId === viewCol.fieldId)
                );

                // Set up columns
                columns = columnsInfo.map(col => ({
                    id: col.fieldName,
                    name: col.fieldName.replace(/^\[.*?\]\.?/g, '')
                        .replace(/(SUM|AVG|COUNT)\(/gi, '')
                        .replace(/[^a-zA-Z0-9 ]/g, ' ')
                        .trim(),
                    dataType: col.dataType // Store data type
                }));

                // Process all pages
                allData = [];
                for (let page = 0; page < dataTableReader.pageCount; page++) {
                    try {
                        const dataTablePage = await dataTableReader.getPageAsync(page);

                        if (!dataTablePage.data || dataTablePage.totalRowCount === 0) {
                            continue;
                        }

                        for (let rowIndex = 0; rowIndex < dataTablePage.totalRowCount; rowIndex++) {
                            try {
                                const row = dataTablePage.data[rowIndex];
                                if (!row) continue;

                                const obj = {};
                                columnsInfo.forEach((col, colIndex) => {
                                    const mappedIndex = indexMap[colIndex];
                                    if (mappedIndex >= 0 && mappedIndex < row.length) {
                                        const cell = row[mappedIndex];
                                        let rawValue;

                                        // PATCH: Intelligently choose between nativeValue and formattedValue
                                        if (cell?.nativeValue !== undefined && cell?.nativeValue !== null) {
                                            const nativeValue = cell.nativeValue;
                                            const formattedValue = cell.formattedValue;

                                            // PATCH: Better date and text handling
                                            if (nativeValue instanceof Date || (typeof nativeValue === 'string' && /^\d{4}-\d{2}-\d{2}/.test(nativeValue))) {
                                                // It's a date - prefer formattedValue for better display
                                                rawValue = formattedValue || nativeValue;
                                            } else if (typeof nativeValue === 'string' || (formattedValue && typeof formattedValue === 'string')) {
                                                // Check if it's alphanumeric or contains special formatting
                                                const formattedStr = (formattedValue || '').toString();
                                                const nativeStr = (nativeValue || '').toString();

                                                // If formatted value has letters, slashes, or other non-numeric chars (excluding basic number formatting)
                                                const hasTextContent = /[a-zA-Z\/]/.test(formattedStr) || /[a-zA-Z\/]/.test(nativeStr);
                                                const hasDatePattern = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{4}-\d{2}-\d{2}/.test(formattedStr);

                                                if (hasTextContent || hasDatePattern) {
                                                    // Use formatted value for text, dates, and mixed content
                                                    rawValue = formattedValue || nativeValue;
                                                } else {
                                                    // Pure numeric - use native value for precision
                                                    rawValue = nativeValue;
                                                }
                                            } else {
                                                // Numeric values - use native for precision
                                                rawValue = nativeValue;
                                            }
                                        } else if (cell?.formattedValue !== undefined && cell?.formattedValue !== null) {
                                            rawValue = cell.formattedValue;
                                        } else {
                                            rawValue = null;
                                        }

                                        // Clean null values immediately but preserve numeric precision
                                        obj[col.fieldName] = isNullValue(rawValue) ? null : rawValue;
                                        obj[col.fieldName + '_formatted'] = cell?.formattedValue || '';
                                    } else {
                                        obj[col.fieldName] = null;
                                    }
                                });
                                allData.push(obj);
                            } catch (rowError) {
                                console.warn(`Error processing row ${rowIndex} on page ${page}:`, rowError);
                                continue;
                            }
                        }
                    } catch (pageError) {
                        console.warn(`Error processing page ${page}:`, pageError);
                        continue;
                    }
                }

                // Clean up null values but preserve numeric precision
                allData.forEach(r => {
                    columns.forEach(c => {
                        if (isNullValue(r[c.id])) {
                            r[c.id] = null;
                        }
                        // Don't modify numeric values - preserve exact precision
                    });
                });

                // Build title column map
                titleColumnMap = {};
                allData.forEach(r => {
                    columns.forEach(c => {
                        if (!titleColumnMap[c.id] && r[c.id])
                            titleColumnMap[c.id] = r[c.id];
                    });
                });

                // Cache the data
                worksheetData[worksheetName] = { allData, columns };

                // Update UI
                populateAvailableColumns();
                updateSelects();
                populateRowFormatFields();
                renderMetricGroups();

            } catch (error) {
                console.error(`Error fetching data for worksheet "${worksheetName}":`, error);

                // Set up empty state
                columns = [];
                allData = [];
                titleColumnMap = {};

                populateAvailableColumns();
                updateSelects();
                populateRowFormatFields();
                renderMetricGroups();

                // Show user-friendly error
                const container = document.getElementById('data-container');
                if (container) {
                    container.innerHTML = `
                <div style="padding: 20px; text-align: center; color: #d32f2f; background-color: #ffebee; border: 1px solid #ffcdd2; border-radius: 4px;">
                    <h3>Error Loading Worksheet Data</h3>
                    <p>Unable to load data from worksheet "${worksheetName}".</p>
                    <p style="font-size: 0.9em; color: #666;">Error: ${error.message}</p>
                    <p style="font-size: 0.9em;">Please try selecting a different worksheet or refresh the dashboard.</p>
                </div>
            `;
                }
            } finally {
                // Always release the data reader
                if (dataTableReader) {
                    try {
                        await dataTableReader.releaseAsync();
                    } catch (releaseError) {
                        console.warn('Error releasing data reader:', releaseError);
                    }
                }
            }
        }

        function populateAvailableColumns() {
            const availableColumns = document.getElementById('available-columns');
            availableColumns.innerHTML = '';
            columns.forEach(col => {
                const option = document.createElement('option');
                option.value = col.id;
                option.textContent = col.name;
                availableColumns.appendChild(option);
            });
        }

        function updateSelects() {
            const selects = ['title-column', 'sheet-name-field', 'header-row-column', 'excel-file-name-field'];
            selects.forEach(selId => {
                const select = document.getElementById(selId);
                select.innerHTML = `<option value="">${selId === 'excel-file-name-field' ? 'None' : 'Select ' + selId.replace('-', ' ')}</option>`;
                columns.forEach(col => {
                    const option = document.createElement('option');
                    option.value = col.id;
                    option.textContent = col.name;
                    select.appendChild(option);
                });
            });
        }

        function initSortables() {
            ['group', 'pivot', 'value'].forEach(type => {
                if (sortables[type]) sortables[type].destroy();
                sortables[type] = Sortable.create(document.getElementById(`${type}-columns`), {
                    group: 'shared',
                    animation: 150,
                    // onSort: generatePivotTable
                });
            });
        }

        window.addToSection = function (type) {
            const selected = Array.from(document.getElementById('available-columns').selectedOptions);

            // In datadump mode, allow both 'group' (Row Groups) and 'value' (Values) sections
            if (exportMode === 'datadump' && type !== 'group' && type !== 'value') {
                alert('In Data Dump mode, you can add columns to Row Groups (for organizing data) or Values (for formatting settings).');
                return;
            }

            const targetList = document.getElementById(`${type}-columns`);

            selected.forEach(option => {
                if (!targetList.querySelector(`[data-id="${option.value}"]`)) {
                    const item = document.createElement('div');
                    item.className = 'sortable-item';
                    item.dataset.id = option.value;
                    item.innerHTML = `
                <span>${option.textContent}</span>
                <button class="format-btn" onclick="openFormatSettings('${option.value}')">‚öôÔ∏è</button>
                <button class="remove-btn" onclick="removeFromSection('${type}', '${option.value}')">√ó</button>
            `;
                    targetList.appendChild(item);
                }
            });
        };

        function removeFromSection(sectionType, columnId) {
            const section = document.getElementById(`${sectionType}-columns`);
            const item = section.querySelector(`[data-id="${columnId}"]`);
            if (item) item.remove();

            // If removing from value section, also remove from any metric groups
            if (sectionType === 'value') {
                metricGroups.forEach(group => {
                    const index = group.fields.indexOf(columnId);
                    if (index !== -1) {
                        group.fields.splice(index, 1);
                    }
                });
                renderMetricGroups();
            }
            // generatePivotTable();
        }

        function getConfig(type) {
            return Array.from(document.getElementById(`${type}-columns`).children).map(item => ({
                id: item.dataset.id,
                name: fieldRenames[item.dataset.id] || item.querySelector('span').textContent
            }));
        }

        async function saveConfiguration() {
            if (!currentWorksheet || currentWorksheet.trim() === '') {
                alert('Please select a worksheet before saving the configuration.');
                return;
            }

            // Retrieve any existing configs
            const savedConfigs = tableau.extensions.settings.get('configs');
            allConfigs = savedConfigs ? JSON.parse(savedConfigs) : {};
            const existingConfig = allConfigs[currentWorksheet] || {};

            // Build the config object
            const config = {
                version: 9, // Increment version for metric groups
                exportMode: exportMode,
                groupColumns: getConfig('group'),
                pivotColumns: getConfig('pivot'),
                valueColumns: getConfig('value'),

                // ADD THIS LINE - for data dump mode, save the row groups as the selected columns
                dataDumpColumns: exportMode === 'datadump' ? getConfig('group').map(col => col.id) : [],

                showSubtotals: document.getElementById('show-subtotals').checked,
                showRowTotals: document.getElementById('show-row-totals').checked,
                showColumnTotals: document.getElementById('show-column-totals').checked,
                rowTotalsLabel: document.getElementById('rowTotalsLabel').value.trim(),
                columnTotalsLabel: document.getElementById('columnTotalsLabel').value.trim(),
                selectedSubtotalLevels: Array.from(document.getElementById('subtotal-level-select').selectedOptions)
                    .map(opt => opt.value),
                tableTitle: document.getElementById('table-title').value,
                titleFontColor: document.getElementById('title-font-color').value.replace('#', ''),
                titleBgColor: document.getElementById('title-bg-color').value.replace('#', ''),
                titleAlignment: document.getElementById('title-alignment').value,
                formatSettings: formatSettings,
                fieldRenames: fieldRenames,
                headerRowsCount: headerRowsCount,
                headerRowSettings: headerRowSettings,
                headerFormatSettings: headerFormatSettings,
                sheetName: document.getElementById('sheet-name').value,
                sheetNameField: document.getElementById('sheet-name-field').value,

                // PATCH: Save separate filenames for each mode
                excelFileName: exportMode === 'formatted' ? document.getElementById('workbook-file-name').value : (existingConfig.excelFileName || 'pivot_data'),
                excelFileNameField: exportMode === 'formatted' ? document.getElementById('excel-file-name-field').value : (existingConfig.excelFileNameField || ''),
                csvZipFileName: exportMode === 'datadump' ? document.getElementById('workbook-file-name').value : (existingConfig.csvZipFileName || 'csv_export'),
                csvZipFileNameField: exportMode === 'datadump' ? document.getElementById('excel-file-name-field').value : (existingConfig.csvZipFileNameField || ''),

                rowTotalsLabel: document.getElementById('rowTotalsLabel').value || 'Row Totals',
                columnTotalsLabel: document.getElementById('columnTotalsLabel').value || 'Grand Total',
                rowFormatSettings: rowFormatSettings,
                metricGroups: metricGroups, // Save metric groups configuration
                subtotalLabels: subtotalLabels,
                useCustomSubtotalLabels: useCustomSubtotalLabels
            };

            // Update entry for this worksheet
            allConfigs[currentWorksheet] = config;

            try {
                // Save new configs back into Tableau settings
                await tableau.extensions.settings.set('configs', JSON.stringify(allConfigs));
                await tableau.extensions.settings.saveAsync();
                alert("Configuration saved");
                // Close the dialog so user knows it worked
                tableau.extensions.ui.closeDialog();
            } catch (error) {
                console.error('Error saving configuration:', error);
                alert("Error saving configuration: " + error.message);
            }
        }



        async function loadConfiguration() {
            const savedConfigs = tableau.extensions.settings.get('configs');
            if (!savedConfigs) return;

            allConfigs = JSON.parse(savedConfigs);
            const config = allConfigs[currentWorksheet];
            if (!config) return;

            // Load export mode FIRST but don't switch yet
            exportMode = config.exportMode || 'formatted';

            formatSettings = config.formatSettings || {};
            fieldRenames = config.fieldRenames || {};
            headerFormatSettings = config.headerFormatSettings || headerFormatSettings;
            headerRowsCount = config.headerRowsCount || 0;
            headerRowSettings = config.headerRowSettings || [];
            tableTitle = config.tableTitle || '';
            titleFontColor = config.titleFontColor || '000000';
            titleBgColor = config.titleBgColor || 'F8F9FA';
            titleAlignment = config.titleAlignment || 'center';
            window.headerRowsCount = headerRowsCount;
            window.headerRowSettings = headerRowSettings;
            window.tableTitle = tableTitle;
            window.titleFontColor = titleFontColor;
            window.titleBgColor = titleBgColor;
            window.titleAlignment = titleAlignment;

            document.getElementById('header-rows-count').value = headerRowsCount;
            applyHeaderRows(); // This will create the configuration buttons

            // Load metric groups configuration
            metricGroups = config.metricGroups || [];
            if (metricGroups.length > 0) {
                metricGroupIdCounter = Math.max(...metricGroups.map(g => g.id)) + 1;
            }
            // PATCH: Load subtotal label configuration
            subtotalLabels = config.subtotalLabels || {};
            useCustomSubtotalLabels = config.useCustomSubtotalLabels || false;
            document.getElementById('use-custom-subtotal-labels').checked = useCustomSubtotalLabels;

            if (useCustomSubtotalLabels) {
                setTimeout(() => updateSubtotalLabelsUI(), 100);
            }

            if (config.rowFormatSettings) {
                rowFormatSettings = config.rowFormatSettings;
                populateRowFormatFields();
                // Recreate rule visualizations
                Object.entries(rowFormatSettings.rules).forEach(([value, color]) => {
                    const ruleDiv = document.createElement('div');
                    ruleDiv.className = 'header-row-item';
                    ruleDiv.innerHTML = `
                <span><strong>${value}</strong></span>
                <div style="background-color:#${color}; width: 20px; height: 20px; border: 1px solid #ccc;"></div>
                <button class="remove-btn" onclick="removeRowFormatRule('${value}')">√ó</button>
            `;
                    document.getElementById('row-format-rules').appendChild(ruleDiv);
                });
            }

            // PATCH: Load appropriate filename based on current export mode
            if (exportMode === 'datadump') {
                document.getElementById('workbook-file-name').value = config.csvZipFileName || 'csv_export';
                document.getElementById('excel-file-name-field').value = config.csvZipFileNameField || '';
            } else {
                document.getElementById('workbook-file-name').value = config.excelFileName || 'pivot_data';
                document.getElementById('excel-file-name-field').value = config.excelFileNameField || '';
            }

            document.getElementById('sheet-name').value = config.sheetName || '';
            document.getElementById('sheet-name-field').value = config.sheetNameField || '';
            document.getElementById('table-title').value = config.tableTitle || '';
            document.getElementById('title-font-color').value = `#${config.titleFontColor || '000000'}`;
            document.getElementById('title-bg-color').value = `#${config.titleBgColor || 'F8F9FA'}`;
            document.getElementById('title-alignment').value = config.titleAlignment || 'center';
            document.getElementById('header-rows-count').value = headerRowsCount;
            document.getElementById('rowTotalsLabel').value = config.rowTotalsLabel || 'Row Totals';
            document.getElementById('columnTotalsLabel').value = config.columnTotalsLabel || 'Column Totals';
            document.getElementById('show-row-totals').addEventListener('change', e => {
                document.getElementById('rowTotalsLabel').style.display = e.target.checked ? 'inline-block' : 'none';
            });
            document.getElementById('show-column-totals').addEventListener('change', e => {
                document.getElementById('columnTotalsLabel').style.display = e.target.checked ? 'inline-block' : 'none';
            });

            ['group', 'pivot', 'value'].forEach(type => {
                const section = document.getElementById(`${type}-columns`);
                section.innerHTML = '';
                (config[`${type}Columns`] || []).forEach(col => {
                    const item = document.createElement('div');
                    item.className = 'sortable-item';
                    item.dataset.id = col.id;
                    item.innerHTML = `
                <span>${col.name}</span>
                <button class="format-btn" onclick="openFormatSettings('${col.id}')">‚öôÔ∏è</button>
                <button class="remove-btn" onclick="removeFromSection('${type}', '${col.id}')">√ó</button>
            `;
                    section.appendChild(item);
                });
            });

            // Load data dump columns back into Row Groups if in datadump mode
            if (exportMode === 'datadump' && config.dataDumpColumns) {
                // Clear existing row groups first (they were just loaded above)
                document.getElementById('group-columns').innerHTML = '';

                // Add the saved dataDumpColumns to Row Groups
                config.dataDumpColumns.forEach(columnId => {
                    const column = columns.find(col => col.id === columnId);
                    if (column) {
                        const item = document.createElement('div');
                        item.className = 'sortable-item';
                        item.dataset.id = column.id;
                        item.innerHTML = `
                    <span>${fieldRenames[column.id] || column.name}</span>
                    <button class="format-btn" onclick="openFormatSettings('${column.id}')">‚öôÔ∏è</button>
                    <button class="remove-btn" onclick="removeFromSection('group', '${column.id}')">√ó</button>
                `;
                        document.getElementById('group-columns').appendChild(item);
                    }
                });
            }

            document.getElementById('show-subtotals').checked = config.showSubtotals || false;
            document.getElementById('show-row-totals').checked = config.showRowTotals || false;
            document.getElementById('show-column-totals').checked = config.showColumnTotals || false;

            const subtotalSelect = document.getElementById('subtotal-level-select');
            Array.from(subtotalSelect.options).forEach(opt => {
                opt.selected = (config.selectedSubtotalLevels || []).includes(opt.value);
            });

            renderMetricGroups(); // Render loaded metric groups
            updateNoGroupsMessage();
            initSortables();

            // Initialize export mode AFTER everything else is loaded
            setTimeout(() => {
                initializeExportModeAfterLoad();
            }, 100); // Small delay to ensure DOM is ready
        }

        function initializeExportModeAfterLoad() {
            // This should be called AFTER all configuration is loaded
            const modeRadio = document.querySelector(`input[name="export-mode"][value="${exportMode}"]`);
            if (modeRadio) {
                modeRadio.checked = true;
                switchExportModeQuiet(exportMode);

                // Update generate button text based on current mode
                const generateBtn = document.getElementById('generate-btn');
                if (generateBtn) {
                    generateBtn.textContent = exportMode === 'datadump' ? 'Generate Data Dump Preview' : 'Generate Pivot Table';
                }
            }
        }

        function showRenameModal() {
            const modal = document.getElementById('rename-modal');
            const list = document.getElementById('rename-fields-list');
            list.innerHTML = '';

            const allFields = [...getConfig('group'), ...getConfig('pivot'), ...getConfig('value')];
            allFields.forEach(field => {
                const div = document.createElement('div');
                div.className = 'rename-field';
                div.innerHTML = `
                <label title="${field.id}">${field.id}</label>
                <input type="text" value="${fieldRenames[field.id] || field.name}">
            `;
                list.appendChild(div);
            });

            modal.style.display = 'block';
        }

        async function updateHeaderRowInputs() {
            const type = document.getElementById('header-row-type').value;
            document.getElementById('text-input-container').style.display = type === 'text' ? 'block' : 'none';
            document.getElementById('column-select-container').style.display = type === 'column' ? 'block' : 'none';
            document.getElementById('refreshDate-options').style.display = type === 'refreshDate' ? 'block' : 'none';
            document.getElementById('header-row-prefix').parentElement.style.display = type === 'refreshDate' ? 'block' : 'none';
            document.getElementById('filter-selection-container').style.display = type === 'filters' ? 'block' : 'none';
            if (type === 'filters') {
                await populateFilters();
            }
        }

        async function populateFilters() {
            const filterList = document.getElementById('filter-list');
            filterList.innerHTML = '';

            // Ensure we have a selected worksheet
            if (!currentWorksheet) {
                filterList.innerHTML = '<div>Please select a worksheet first</div>';
                return;
            }

            const ws = tableau.extensions.dashboardContent.dashboard.worksheets
                .find(w => w.name === currentWorksheet);

            if (!ws) {
                filterList.innerHTML = '<div>Worksheet not found</div>';
                return;
            }

            try {
                allFilters = await ws.getFiltersAsync();
                if (allFilters.length === 0) {
                    filterList.innerHTML = '<div>No filters available for this worksheet</div>';
                    return;
                }

                allFilters.forEach(filter => {
                    const div = document.createElement('div');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `filter-${filter.fieldName}`;
                    checkbox.value = filter.fieldName;
                    checkbox.checked = selectedFilters.includes(filter.fieldName);

                    const label = document.createElement('label');
                    label.htmlFor = `filter-${filter.fieldName}`;
                    label.textContent = filter.fieldName;

                    div.appendChild(checkbox);
                    div.appendChild(label);
                    filterList.appendChild(div);
                });
            } catch (error) {
                console.error('Error fetching filters:', error);
                filterList.innerHTML = `<div>Error loading filters: ${error.message}</div>`;
            }
        }

        function closeRenameModal() {
            document.getElementById('rename-modal').style.display = 'none';
        }

        function saveRenames() {
            const inputs = document.querySelectorAll('#rename-fields-list .rename-field input');
            inputs.forEach(input => {
                const originalName = input.previousElementSibling.textContent;
                const newName = input.value.trim();
                fieldRenames[originalName] = newName || originalName;
            });
            closeRenameModal();
            // generatePivotTable();
        }

        function showHeaderFormatModal() {
            document.getElementById('header-format-modal').style.display = 'block';
            loadHeaderFormatSettings();
        }

        function closeHeaderFormatModal() {
            document.getElementById('header-format-modal').style.display = 'none';
        }

        function showHeaderFormatTab(tabName) {
            document.querySelectorAll('#header-format-modal .format-tab, #header-format-modal .format-content')
                .forEach(el => el.classList.remove('active'));
            document.getElementById(`${tabName}-format`).classList.add('active');
            document.querySelector(`[onclick="showHeaderFormatTab('${tabName}')"]`).classList.add('active');
        }

        function loadHeaderFormatSettings() {
            document.getElementById('row-group-font-color').value = `#${headerFormatSettings.rowGroups.fontColor}`;
            document.getElementById('row-group-bg-color').value = `#${headerFormatSettings.rowGroups.bgColor}`;
            document.getElementById('row-group-alignment').value = headerFormatSettings.rowGroups.textAlign;

            document.getElementById('column-group-font-color').value = `#${headerFormatSettings.columnGroups.fontColor}`;
            document.getElementById('column-group-bg-color').value = `#${headerFormatSettings.columnGroups.bgColor}`;
            document.getElementById('column-group-alignment').value = headerFormatSettings.columnGroups.textAlign;

            document.getElementById('totals-font-color').value = `#${headerFormatSettings.totals.fontColor}`;
            document.getElementById('totals-bg-color').value = `#${headerFormatSettings.totals.bgColor}`;
            document.getElementById('totals-alignment').value = headerFormatSettings.totals.textAlign;

            document.getElementById('subtotals-font-color').value = `#${headerFormatSettings.subtotals.fontColor}`;
            document.getElementById('subtotals-bg-color').value = `#${headerFormatSettings.subtotals.bgColor}`;
            document.getElementById('subtotals-alignment').value = headerFormatSettings.subtotals.textAlign;
        }

        function saveHeaderFormatSettings() {
            headerFormatSettings = {
                rowGroups: {
                    fontColor: document.getElementById('row-group-font-color').value.replace('#', ''),
                    bgColor: document.getElementById('row-group-bg-color').value.replace('#', ''),
                    textAlign: document.getElementById('row-group-alignment').value
                },
                columnGroups: {
                    fontColor: document.getElementById('column-group-font-color').value.replace('#', ''),
                    bgColor: document.getElementById('column-group-bg-color').value.replace('#', ''),
                    textAlign: document.getElementById('column-group-alignment').value
                },
                totals: {
                    fontColor: document.getElementById('totals-font-color').value.replace('#', ''),
                    bgColor: document.getElementById('totals-bg-color').value.replace('#', ''),
                    textAlign: document.getElementById('totals-alignment').value
                },
                subtotals: {
                    fontColor: document.getElementById('subtotals-font-color').value.replace('#', ''),
                    bgColor: document.getElementById('subtotals-bg-color').value.replace('#', ''),
                    textAlign: document.getElementById('subtotals-alignment').value
                }
            };
            // generatePivotTable();
            closeHeaderFormatModal();
        }

        function applyHeaderStyles(element, headerType) {
            const settings = headerFormatSettings[headerType] || {};
            element.style.backgroundImage = 'none';
            element.style.color = `#${settings.fontColor || '000000'}`;
            element.style.backgroundColor = `#${settings.bgColor || 'FFFFFF'}`;
            element.style.textAlign = settings.textAlign || 'left';
            element.style.border = '1px solid #808080';
        }

        function openFormatSettings(columnId) {
            currentFormattingColumn = columnId;
            formatSettings[columnId] = formatSettings[columnId] || {
                fontColor: '000000',
                bgColor: 'FFFFFF',
                formatType: 'text',
                currencySymbol: '',
                decimals: null, // PATCH: Change from 2 to null to preserve precision
                conditions: []
            };

            document.getElementById('format-type').value = formatSettings[columnId].formatType;
            document.getElementById('currency-symbol').value = formatSettings[columnId].currencySymbol;
            // PATCH: Handle null decimals in UI
            document.getElementById('decimals').value = formatSettings[columnId].decimals === null ? '' : formatSettings[columnId].decimals;

            // PATCH: Load date format
            document.getElementById('date-format').value = formatSettings[columnId].dateFormat || 'MM/DD/YYYY';
            document.getElementById('font-color').value = `#${formatSettings[columnId].fontColor}`;
            document.getElementById('bg-color').value = `#${formatSettings[columnId].bgColor}`;
            document.getElementById('currency-symbol-container').style.display =
                formatSettings[columnId].formatType === 'currency' ? 'flex' : 'none';
            document.getElementById('decimals-container').style.display =
                ['number', 'currency', 'percentage'].includes(formatSettings[columnId].formatType) ? 'flex' : 'none';

            // PATCH: Show/hide date format container
            document.getElementById('date-format-container').style.display =
                formatSettings[columnId].formatType === 'date' ? 'flex' : 'none';
            loadConditions(formatSettings[columnId].conditions);
            document.getElementById('format-settings').style.display = 'block';
        }

        function closeFormatSettings() {
            document.getElementById('format-settings').style.display = 'none';
            currentFormattingColumn = null;
        }

        function showFormatTab(tabName) {
            document.querySelectorAll('.format-tab, .format-content').forEach(el => el.classList.remove('active'));
            document.getElementById(`${tabName}-format`).classList.add('active');
            document.querySelector(`[onclick="showFormatTab('${tabName}')"]`).classList.add('active');
        }

        function addNewCondition() {
            const container = document.getElementById('conditions-container');
            const div = document.createElement('div');
            div.className = 'condition-row';

            const fieldOptions = columns.map(col =>
                `<option value="${col.id}">${col.name}</option>`
            ).join('');

            div.innerHTML = `
            <select class="condition-operator">
                <option value="==">Equal To</option>
                <option value=">">Greater Than</option>
                <option value="<">Less Than</option>
            </select>
            <select class="condition-compare-type">
                <option value="value">Value</option>
                <option value="field">Field</option>
            </select>
            <input type="text" class="condition-value" placeholder="Enter value">
            <select class="condition-field" style="display: none;">
                <option value="">Select Field</option>
                ${fieldOptions}
            </select>
            <label>Font:</label>
            <input type="color" class="condition-font" value="#000000">
            <label>Background:</label>
            <input type="color" class="condition-bg" value="#FFFFFF">
            <label>Shape:</label>
            <input type="text" class="condition-shape" placeholder="üî∫ / üí° / ‚úîÔ∏è" maxlength="3">
            <button onclick="this.parentElement.remove()">√ó</button>
        `;

            const compareType = div.querySelector('.condition-compare-type');
            const valueInput = div.querySelector('.condition-value');
            const fieldSelect = div.querySelector('.condition-field');
            compareType.addEventListener('change', () => {
                valueInput.style.display = compareType.value === 'value' ? 'inline-block' : 'none';
                fieldSelect.style.display = compareType.value === 'field' ? 'inline-block' : 'none';
            });

            container.appendChild(div);
        }

        function loadConditions(conditions) {
            const container = document.getElementById('conditions-container');
            container.innerHTML = '';
            conditions.forEach(cond => {
                const fieldOptions = columns.map(col =>
                    `<option value="${col.id}" ${cond.compareType === 'field' && cond.value === col.id ? 'selected' : ''}>${col.name}</option>`
                ).join('');

                const div = document.createElement('div');
                div.className = 'condition-row';
                div.innerHTML = `
                <select class="condition-operator">
                    <option value="==" ${cond.operator === '==' ? 'selected' : ''}>Equal To</option>
                    <option value=">" ${cond.operator === '>' ? 'selected' : ''}>Greater Than</option>
                    <option value="<" ${cond.operator === '<' ? 'selected' : ''}>Less Than</option>
                </select>
                <select class="condition-compare-type">
                    <option value="value" ${cond.compareType === 'value' ? 'selected' : ''}>Value</option>
                    <option value="field" ${cond.compareType === 'field' ? 'selected' : ''}>Field</option>
                </select>
                <input type="text" class="condition-value" value="${cond.compareType === 'value' ? cond.value : ''}" placeholder="Enter value" style="${cond.compareType === 'field' ? 'display: none;' : ''}">
                <select class="condition-field" style="${cond.compareType === 'value' ? 'display: none;' : ''}">
                    <option value="">Select Field</option>
                    ${fieldOptions}
                </select>
                <label>Font:</label>
                <input type="color" class="condition-font" value="#${cond.fontColor}">
                <label>Background:</label>
                <input type="color" class="condition-bg" value="#${cond.bgColor}">
                <label>Shape:</label>
                <input type="text" class="condition-shape" value="${cond.shape || ''}" placeholder="üî∫ / üí° / ‚úîÔ∏è" maxlength="3">
                <button onclick="this.parentElement.remove()">√ó</button>
            `;

                const compareType = div.querySelector('.condition-compare-type');
                const valueInput = div.querySelector('.condition-value');
                const fieldSelect = div.querySelector('.condition-field');
                compareType.addEventListener('change', () => {
                    valueInput.style.display = compareType.value === 'value' ? 'inline-block' : 'none';
                    fieldSelect.style.display = compareType.value === 'field' ? 'inline-block' : 'none';
                });

                container.appendChild(div);
            });
        }

        function applyHeaderRows() {
            const newCount = parseInt(document.getElementById('header-rows-count').value, 10) || 0;

            // Update the global count
            headerRowsCount = newCount;

            if (newCount < headerRowSettings.length) {
                headerRowSettings = headerRowSettings.slice(0, newCount);
            }
            while (headerRowSettings.length < newCount) {
                headerRowSettings.push({
                    type: 'text',
                    text: `Header Row ${headerRowSettings.length + 1}`,
                    column: '',
                    fontColor: '000000',
                    bgColor: 'F8F9FA',
                    textAlign: 'left'
                });
            }

            // Update global variables
            window.headerRowsCount = headerRowsCount;
            window.headerRowSettings = headerRowSettings;

            // Create clickable header row elements for configuration
            const container = document.querySelector('.header-rows-control');

            // Remove existing header row buttons
            const existingButtons = container.querySelectorAll('.header-row-config-btn');
            existingButtons.forEach(btn => btn.remove());

            // Add configuration buttons for each header row
            for (let i = 0; i < newCount; i++) {
                const button = document.createElement('button');
                button.className = 'header-row-config-btn';
                button.textContent = `Configure Row ${i + 1}`;
                button.style.margin = '5px';
                button.onclick = () => configureHeaderRow(i);
                container.appendChild(button);
            }

            // generatePivotTable();
        }

        async function configureHeaderRow(index) {
            const modal = document.getElementById('header-row-modal');
            const settings = headerRowSettings[index] || {
                type: 'text',
                text: `Header Row ${index + 1}`,
                column: '',
                fontColor: '000000',
                bgColor: 'F8F9FA',
                textAlign: 'left'
            };

            document.getElementById('current-header-row-index').value = index;
            document.getElementById('header-row-type').value = settings.type || 'text';
            document.getElementById('header-row-text').value = settings.text || '';
            document.getElementById('header-row-column').value = settings.column || '';
            document.getElementById('header-row-font-color').value = `#${settings.fontColor}`;
            document.getElementById('header-row-bg-color').value = `#${settings.bgColor}`;
            document.getElementById('header-row-alignment').value = settings.textAlign;

            if (settings.type === 'filters' || document.getElementById('header-row-type').value === 'filters') {
                selectedFilters = settings.selectedFilters || [];
                await populateFilters();
            }

            // Set timezone and date format if they exist
            if (settings.timeZone) {
                document.getElementById('refresh-timezone').value = settings.timeZone;
            }
            if (settings.dateFormat) {
                document.getElementById('refresh-format').value = settings.dateFormat;
            }

            updateHeaderRowInputs();
            modal.style.display = 'block';
        }

        // Custom date formatter to handle different separators
        function formatDateWithCustomSeparator(date, formatOptions, timeZone) {
            // Handle custom format styles (dash, dot)
            const formatStyle = formatOptions.formatStyle;
            const cleanOptions = { ...formatOptions };
            delete cleanOptions.formatStyle; // Remove custom property

            if (timeZone) {
                cleanOptions.timeZone = timeZone;
            }

            // Get the formatted date
            let formattedDate = new Intl.DateTimeFormat(undefined, cleanOptions).format(date);

            // Apply custom separators
            if (formatStyle === 'dash') {
                formattedDate = formattedDate.replace(/\//g, '-');
            } else if (formatStyle === 'dot') {
                formattedDate = formattedDate.replace(/\//g, '.');
            }

            // PATCH: Convert am/pm to AM/PM for better formatting
            formattedDate = formattedDate.replace(/\bam\b/gi, 'AM').replace(/\bpm\b/gi, 'PM');

            return formattedDate;
        }

        function saveHeaderRowConfig() {
            const index = parseInt(document.getElementById('current-header-row-index').value, 10);
            if (isNaN(index) || index < 0) return;

            const settings = {
                type: document.getElementById('header-row-type').value,
                text: document.getElementById('header-row-text').value,
                column: document.getElementById('header-row-column').value,
                fontColor: document.getElementById('header-row-font-color').value.replace('#', ''),
                bgColor: document.getElementById('header-row-bg-color').value.replace('#', ''),
                textAlign: document.getElementById('header-row-alignment').value
            };

            // Add time zone and date format for refreshDate type
            if (settings.type === 'refreshDate') {
                settings.timeZone = document.getElementById('refresh-timezone').value;
                settings.dateFormat = document.getElementById('refresh-format').value;
                settings.prefixText = document.getElementById('header-row-prefix').value || '';
            } else if (settings.type === 'filters') {
                // Get selected filters
                settings.selectedFilters = Array.from(
                    document.querySelectorAll('#filter-list input[type="checkbox"]:checked')
                ).map(checkbox => checkbox.value);
            }

            // Ensure headerRowSettings array exists and is large enough
            while (headerRowSettings.length <= index) {
                headerRowSettings.push({
                    type: 'text',
                    text: `Header Row ${headerRowSettings.length + 1}`,
                    column: '',
                    fontColor: '000000',
                    bgColor: 'F8F9FA',
                    textAlign: 'left'
                });
            }

            headerRowSettings[index] = settings;
            window.headerRowSettings = headerRowSettings;
            closeHeaderRowModal();
            // generatePivotTable();
        }

        function closeHeaderRowModal() {
            document.getElementById('header-row-modal').style.display = 'none';
        }

        function saveFormatSettings() {
            if (!currentFormattingColumn) return;

            // PATCH: Handle empty decimals input
            const decimalsInput = document.getElementById('decimals').value;
            const decimalsValue = decimalsInput === '' ? null : parseInt(decimalsInput, 10);

            formatSettings[currentFormattingColumn] = {
                fontColor: document.getElementById('font-color').value.replace('#', ''),
                bgColor: document.getElementById('bg-color').value.replace('#', ''),
                formatType: document.getElementById('format-type').value,
                currencySymbol: document.getElementById('currency-symbol').value || '',
                decimals: decimalsValue, // PATCH: Use null for empty input
                dateFormat: document.getElementById('date-format').value || 'MM/DD/YYYY', // PATCH: Save date format
                conditions: []
            };

            document.querySelectorAll('.condition-row').forEach(row => {
                const operator = row.querySelector('.condition-operator').value;
                const compareType = row.querySelector('.condition-compare-type').value;
                const value = compareType === 'value' ?
                    row.querySelector('.condition-value').value :
                    row.querySelector('.condition-field').value;
                const fontColor = row.querySelector('.condition-font').value.replace('#', '');
                const bgColor = row.querySelector('.condition-bg').value.replace('#', '');
                const shape = row.querySelector('.condition-shape').value.trim();

                formatSettings[currentFormattingColumn].conditions.push({
                    operator,
                    compareType,
                    value,
                    fontColor,
                    bgColor,
                    shape
                });
            });

            closeFormatSettings();
            // generatePivotTable();
        }

        function formatDateString(value) {
            if (isNullValue(value)) return '';

            // PATCH: Preserve all date formatting from Tableau
            if (typeof value === 'string') {
                // Don't modify any date strings - Tableau has already formatted them correctly
                return value;
            }

            if (value instanceof Date) {
                // Convert Date objects to readable format
                return value.toLocaleDateString();
            }

            return value.toString();
        }


        function createGroupCell(value, columnId, rowBgColor = null) {
            const td = document.createElement('td');
            const settings = formatSettings[columnId] || {};

            // Clean display value - show blank for nulls
            let textValue = cleanDisplayValue(value);

            td.setAttribute('data-value', textValue);
            td.setAttribute('data-column-id', columnId);
            td.textContent = textValue;

            let conditionApplied = false;
            if (Array.isArray(settings.conditions)) {
                for (const cond of settings.conditions) {
                    let conditionMet = false;
                    if (cond.operator === '==' && textValue === cond.value?.toString()) {
                        conditionMet = true;
                    } else if (['>', '<'].includes(cond.operator)) {
                        const numValue = parseFloat(textValue);
                        const condValue = parseFloat(cond.value);
                        if (!isNaN(numValue) && !isNaN(condValue)) {
                            conditionMet = cond.operator === '>' ? numValue > condValue : numValue < condValue;
                        }
                    }
                    if (conditionMet) {
                        td.style.color = `#${cond.fontColor}`;
                        conditionApplied = true;
                        break;
                    }
                }
            }

            if (!conditionApplied) {
                td.style.color = `#${settings.fontColor || '000000'}`;
            }

            td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${settings.bgColor || 'FFFFFF'}`;
            return td;
        }

        // Replace the formatValueForExcel function in config.html with this version:
        function formatValueForExcel(value, columnId, isTotal = false, headerType = null, row = null) {
            const settings = formatSettings[columnId] || {};
            const decimals = settings.formatType === 'text' ? null : (settings.decimals ?? null);
            const fmtType = settings.formatType || 'number';
            const currSym = settings.currencySymbol || '$';
            let shapePrefix = '';

            // Handle null values first
            if (value === null || value === undefined || isNullValue(value)) {
                return {
                    displayText: '',
                    shapePrefix: '',
                    rawValue: null
                };
            }

            // Check for conditional shape prefix
            if (!isTotal && settings.conditions) {
                const nv = parseFloat(value);
                for (const cond of settings.conditions) {
                    let cmpVal = cond.compareType === 'field' ? 0 : cond.value;
                    const cv = parseFloat(cmpVal);
                    let met = false;

                    if (cond.operator === '==' && value?.toString() === cmpVal?.toString()) {
                        met = true;
                    } else if (!isNaN(nv) && !isNaN(cv)) {
                        switch (cond.operator) {
                            case '>': met = nv > cv; break;
                            case '<': met = nv < cv; break;
                            case '>=': met = nv >= cv; break;
                            case '<=': met = nv <= cv; break;
                            case '!=': met = nv != cv; break;
                        }
                    }

                    if (met) {
                        shapePrefix = cond.shape || '';
                        break;
                    }
                }
            }

            // Build displayed string - PRESERVE EXACT PRECISION
            let baseText;

            // NEW LOGIC: Use formattedValue by default if no specific format is configured
            const hasSpecificFormat = settings.formatType && settings.formatType !== 'text';
            const hasDecimals = settings.decimals !== null && settings.decimals !== undefined;

            if (!hasSpecificFormat && !hasDecimals) {
                // Try to use the formatted value from the row if available
                if (row && row[columnId + '_formatted']) {
                    baseText = row[columnId + '_formatted'];
                } else {
                    baseText = (value ?? '').toString();
                }
                return {
                    displayText: shapePrefix ? (shapePrefix + ' ' + baseText) : baseText,
                    shapePrefix: shapePrefix,
                    rawValue: value
                };
            }
            if (fmtType === 'text') {
                baseText = (value ?? '').toString();
            } else {
                const numValue = parseFloat(value);
                if (isNaN(numValue)) {
                    baseText = (value ?? '').toString();
                } else {
                    if (decimals === null || decimals === undefined) {
                        // No specific decimal formatting - preserve original precision exactly
                        // Use the original value string representation to maintain exact digits
                        const originalStr = value.toString();

                        switch (fmtType) {
                            case 'currency':
                                baseText = currSym + originalStr;
                                break;
                            case 'percentage':
                                // For percentage, we need to multiply by 100 but preserve precision
                                const percentValue = numValue * 100;
                                baseText = percentValue.toString() + '%';
                                break;
                            case 'date': // PATCH: Handle date formatting
                                try {
                                    const dateVal = new Date(value);
                                    if (!isNaN(dateVal.getTime())) {
                                        // Simple formatter based on the format string
                                        const formatStr = settings.dateFormat || 'MM/DD/YYYY';
                                        const day = dateVal.getDate().toString().padStart(2, '0');
                                        const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                        const year = dateVal.getFullYear().toString();

                                        // Basic replacement - can be expanded for more tokens
                                        baseText = formatStr
                                            .replace('YYYY', year)
                                            .replace('MM', month)
                                            .replace('DD', day);
                                    } else {
                                        baseText = originalStr;
                                    }
                                } catch (e) {
                                    baseText = originalStr;
                                }
                                break;
                            default:
                                baseText = originalStr; // Use original string to preserve exact digits
                        }
                    } else if (decimals === 0) {
                        switch (fmtType) {
                            case 'currency': baseText = currSym + Math.round(numValue).toLocaleString(); break;
                            case 'percentage': baseText = Math.round(numValue * 100) + '%'; break;
                            default: baseText = Math.round(numValue).toLocaleString();
                        }
                    } else {
                        switch (fmtType) {
                            case 'currency': baseText = currSym + numValue.toFixed(decimals); break;
                            case 'percentage': baseText = (numValue * 100).toFixed(decimals) + '%'; break;
                            default: baseText = numValue.toFixed(decimals);
                        }
                    }
                }
            }

            return {
                displayText: shapePrefix ? (shapePrefix + ' ' + baseText) : baseText,
                shapePrefix: shapePrefix,
                rawValue: value
            };
        }

        // In createValueCell function, replace the formattedValue assignment:
        function createValueCell(value, columnId, rowBgColor = null) {
            const td = document.createElement('td');
            const settings = formatSettings[columnId] || {};

            // Handle null values first - show as blank
            if (value === null || value === undefined || isNullValue(value)) {
                td.setAttribute('data-value', '');
                td.setAttribute('data-column-id', columnId);
                td.textContent = '';
                td.style.color = `#${settings.fontColor || '000000'}`;
                td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${settings.bgColor || 'FFFFFF'}`;
                return td;
            }

            // DIRECT APPROACH: If no specific formatting is set, show the raw value exactly
            const decimals = settings.decimals;
            const formatType = settings.formatType || 'text';

            let displayValue;

            if (formatType !== 'date' && (formatType === 'text' || (decimals === null || decimals === undefined))) {
                // Show the raw value exactly as it is
                displayValue = value.toString();
            } else {
                // Apply specific formatting only when explicitly requested
                const formattedResult = formatValueForExcel(value, columnId);
                displayValue = formattedResult.displayText;
            }

            td.setAttribute('data-value', value.toString());
            td.setAttribute('data-column-id', columnId);

            // Apply conditional formatting...
            let applied = false;
            for (const cond of settings.conditions || []) {
                let meet = false, compareVal;
                if (cond.compareType === 'field') {
                    const rowObj = allData.find(r => r[columnId] === value);
                    compareVal = rowObj ? rowObj[cond.value] : null;
                } else {
                    compareVal = cond.value;
                }
                const cmpNum = parseFloat(compareVal);
                const num = parseFloat(value);
                if (cond.operator === '==' && value.toString() === compareVal?.toString()) {
                    meet = true;
                } else if (!isNaN(num) && !isNaN(cmpNum)) {
                    meet = cond.operator === '>' ? num > cmpNum
                        : cond.operator === '<' ? num < cmpNum
                            : false;
                }
                if (meet) {
                    td.style.color = `#${cond.fontColor}`;
                    td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${cond.bgColor}`;
                    td.textContent = cond.shape ? (cond.shape + ' ' + displayValue) : displayValue;
                    applied = true;
                    break;
                }
            }

            if (!applied) {
                td.textContent = displayValue; // Use the exact display value
                td.style.color = `#${settings.fontColor || '000000'}`;
                td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${settings.bgColor || 'FFFFFF'}`;
            }

            return td;
        }


        function getRowBackgroundColor(rowValues, groupCols, maxLevel = null) {
            if (!groupCols.length) return null;

            for (let i = 0; i < groupCols.length && (maxLevel === null || i <= maxLevel); i++) {
                const colId = groupCols[i].id;
                const settings = formatSettings[colId] || {};
                const textValue = rowValues[i]?.toString() ?? '';

                if (Array.isArray(settings.conditions)) {
                    for (const cond of settings.conditions) {
                        let conditionMet = false;
                        if (cond.operator === '==' && textValue === cond.value?.toString()) {
                            conditionMet = true;
                        } else if (['>', '<'].includes(cond.operator)) {
                            const numValue = parseFloat(textValue);
                            const condValue = parseFloat(cond.value);
                            if (!isNaN(numValue) && !isNaN(condValue)) {
                                conditionMet = cond.operator === '>' ? numValue > condValue : numValue < condValue;
                            }
                        }
                        if (conditionMet) {
                            return cond.bgColor;
                        }
                    }
                }
            }
            return null;
        }

        function generateAllCombinations(pivotCols) {
            if (pivotCols.length === 0) return [{}];

            const seen = new Set();
            const validCombinations = [];

            allData.forEach(row => {
                const combo = {};
                pivotCols.forEach(p => combo[p.id] = row[p.id]?.toString() || '');
                const key = JSON.stringify(combo);
                if (!seen.has(key)) {
                    seen.add(key);
                    validCombinations.push(combo);
                }
            });

            return validCombinations;
        }

        function createHeaderStructure(pivotCols, combinations) {
            if (!pivotCols.length) return [];

            const field = pivotCols[0].id;
            const groups = new Map();

            combinations.forEach(combo => {
                const value = combo[field];
                if (!groups.has(value)) {
                    groups.set(value, {
                        value: value,
                        span: 1,
                        children: pivotCols.length > 1 ?
                            createHeaderStructure(pivotCols.slice(1), combinations.filter(c => c[field] === value)) : null
                    });
                } else {
                    groups.get(value).span++;
                }
            });

            return Array.from(groups.values());
        }

        function createHeaderLevels(pivotCols, structure, levels = [], depth = 0) {
            if (!structure || structure.length === 0) return levels;

            levels[depth] = levels[depth] || [];
            structure.forEach(group => {
                levels[depth].push({ value: group.value, span: group.span });
                if (group.children) {
                    createHeaderLevels(pivotCols.slice(1), group.children, levels, depth + 1);
                }
            });

            for (let i = depth + 1; i < pivotCols.length; i++) {
                levels[i] = levels[i] || [];
            }

            return levels;
        }

        // NEW FUNCTION: Create hierarchical header structure for metric groups
        function createMetricGroupHeaders(valueCols, colKeys) {
            if (metricGroups.length === 0) {
                // No grouping, return standard headers
                return {
                    hasGroups: false,
                    headers: valueCols.map(v => ({
                        name: fieldRenames[v.id] || v.name,
                        span: colKeys.length || 1
                    }))
                };
            }

            const groupHeaders = [];
            const subHeaders = [];

            // Create headers for each metric group
            metricGroups.forEach(group => {
                if (group.fields.length > 0) {
                    groupHeaders.push({
                        name: group.name,
                        span: group.fields.length * (colKeys.length || 1),
                        isGroup: true
                    });

                    // Add individual metric headers under this group
                    group.fields.forEach(fieldId => {
                        const field = valueCols.find(v => v.id === fieldId);
                        if (field) {
                            subHeaders.push({
                                name: fieldRenames[field.id] || field.name,
                                span: colKeys.length || 1,
                                groupId: group.id
                            });
                        }
                    });
                }
            });

            // Add ungrouped metrics
            const groupedFieldIds = metricGroups.flatMap(g => g.fields);
            const ungroupedFields = valueCols.filter(v => !groupedFieldIds.includes(v.id));

            ungroupedFields.forEach(field => {
                groupHeaders.push({
                    name: fieldRenames[field.id] || field.name,
                    span: colKeys.length || 1,
                    isGroup: false
                });
                subHeaders.push({
                    name: fieldRenames[field.id] || field.name,
                    span: colKeys.length || 1,
                    ungrouped: true
                });
            });

            return {
                hasGroups: metricGroups.length > 0,
                groupHeaders,
                subHeaders
            };
        }

        function generateDataDumpPreview() {
            if (!allData.length) {
                const container = document.getElementById('data-container');
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No data available for preview.</div>';
                return;
            }

            const container = document.getElementById('data-container');
            const previewData = allData.slice(0, 10);

            // UPDATED: Get selected columns from BOTH Row Groups AND Values sections
            const rowGroupColumns = getConfig('group');
            const valueColumns = getConfig('value');

            // Combine both sections, removing duplicates by ID
            const combinedColumns = [];
            const seenIds = new Set();

            [...rowGroupColumns, ...valueColumns].forEach(col => {
                if (!seenIds.has(col.id)) {
                    seenIds.add(col.id);
                    combinedColumns.push(col);
                }
            });

            const selectedColumnIds = combinedColumns.length > 0
                ? combinedColumns.map(col => col.id)
                : columns.map(col => col.id);

            const selectedColumns = selectedColumnIds
                .map(id => columns.find(c => c.id === id))
                .filter(Boolean);

            const table = document.createElement('table');
            table.id = 'data-dump-preview';
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';

            // Add header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            selectedColumns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = fieldRenames[col.id] || col.name;
                th.style.border = '1px solid #ddd';
                th.style.padding = '8px';
                th.style.backgroundColor = '#f5f5f5';
                th.style.textAlign = 'left';
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Add data rows with proper formatting
            const tbody = document.createElement('tbody');
            previewData.forEach((row, index) => {
                const tr = document.createElement('tr');
                if (index % 2 === 1) {
                    tr.style.backgroundColor = '#f9f9f9';
                }

                selectedColumns.forEach(col => {
                    const td = document.createElement('td');
                    let value = row[col.id];

                    // Apply formatting settings from both Row Groups and Values sections
                    if (value !== null && value !== undefined && !isNullValue(value)) {
                        // Use the shared formatting function
                        const formattedResult = formatValueForExcel(value, col.id);
                        value = formattedResult.displayText;
                    } else {
                        value = cleanDisplayValue(value);
                    }

                    td.textContent = value;
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '8px';
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            table.appendChild(tbody);

            // Updated info message
            const info = document.createElement('div');
            info.style.padding = '15px';
            info.style.backgroundColor = '#e7f3ff';
            info.style.border = '1px solid #b3d9ff';
            info.style.borderRadius = '4px';
            info.style.marginBottom = '15px';
            info.innerHTML = `
        <strong>üìã Data Dump Preview</strong><br>
        Showing first 10 rows of ${allData.length} total rows with ${selectedColumns.length} selected columns.<br>
        Add columns to "Row Groups" to select which fields to export. Add columns to "Values" to apply formatting settings.<br>
        <em>Note: Preview shows formatted values as they will appear in the CSV export.</em>
    `;

            container.innerHTML = '';
            container.appendChild(info);
            container.appendChild(table);
        }
        async function generatePivotTable() {
            const groupCols = getConfig('group');
            const pivotCols = getConfig('pivot');
            const valueCols = getConfig('value');
            const showRowTotals = document.getElementById('show-row-totals').checked;
            const showColumnTotals = document.getElementById('show-column-totals').checked;
            const showSubtotals = document.getElementById('show-subtotals').checked;
            const rowTotalsLabel = document.getElementById('rowTotalsLabel').value.trim() || 'Row Totals';
            const columnTotalsLabel = document.getElementById('columnTotalsLabel').value.trim() || 'Column Totals';
            const headerRowsCount = window.headerRowsCount || 0;
            const headerRowSettings = window.headerRowSettings || [];
            const tableTitle = window.tableTitle || '';
            const titleFontColor = window.titleFontColor || '000000';
            const titleBgColor = window.titleBgColor || 'FFFFFF';
            const titleAlignment = window.titleAlignment || 'left';
            const fieldRenames = window.fieldRenames || {};
            const currentWorksheetName = window.currentWorksheet;
            const selectedSubtotalLevels = Array.from(
                document.getElementById('subtotal-level-select').selectedOptions
            ).map(opt => parseInt(opt.value, 10));

            // Check if we have the required columns to build a pivot table
            if (groupCols.length === 0) {
                const container = document.getElementById('data-container');
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Please add at least one field to Row Groups to generate a preview.</div>';
                return;
            }

            // 1) Pre-compute row-key -> array of rows for multi-rule formatting
            const rowKeyToRows = new Map();
            if (rowFormatSettings.field && groupCols.length) {
                allData.forEach(r => {
                    const key = groupCols.map(gc => r[gc.id]).join('|');
                    if (!rowKeyToRows.has(key)) rowKeyToRows.set(key, []);
                    rowKeyToRows.get(key).push(r);
                });
            }

            // 2) Build pivotMap and key sets with proper null handling
            const pivotMap = new Map();
            const rowKeysSet = new Set();
            const colKeysSet = new Set();

            // First pass: collect all row and column keys
            allData.forEach(row => {
                const rowKey = groupCols.map(g => row[g.id] || '').join('|');
                const colKey = pivotCols.map(p => row[p.id] || '').join('|');
                rowKeysSet.add(rowKey);
                colKeysSet.add(colKey);
            });

            const rowKeys = Array.from(rowKeysSet);
            const colKeys = Array.from(colKeysSet);

            // Initialize pivot map with null values
            rowKeys.forEach(rowKey => {
                colKeys.forEach(colKey => {
                    const mapKey = `${rowKey}>>>${colKey}`;
                    const cellData = {};
                    valueCols.forEach(v => {
                        cellData[v.id] = null; // Initialize with null instead of 0
                    });
                    pivotMap.set(mapKey, cellData);
                });
            });

            // Second pass: aggregate data with proper null handling
            allData.forEach(row => {
                const rowKey = groupCols.map(g => row[g.id] || '').join('|');
                const colKey = pivotCols.map(p => row[p.id] || '').join('|');
                const mapKey = `${rowKey}>>>${colKey}`;

                const cellData = pivotMap.get(mapKey);
                if (cellData) {
                    valueCols.forEach(v => {
                        const rawVal = row[v.id];
                        const parsedValue = parseValueForAggregation(rawVal);

                        // Use proper aggregation logic
                        cellData[v.id] = aggregateValues(cellData[v.id], parsedValue);
                    });
                }
            });;

            // PERFORMANCE CHECK: If too many rows, skip preview generation
            const MAX_PREVIEW_ROWS = 20000;
            let estimatedRows = rowKeys.length;

            // Add estimated subtotal rows
            if (showSubtotals && selectedSubtotalLevels.length > 0) {
                selectedSubtotalLevels.forEach(level => {
                    const uniqueValuesAtLevel = new Set();
                    rowKeys.forEach(rk => {
                        const levelValue = rk.split('|').slice(0, level + 1).join('|');
                        uniqueValuesAtLevel.add(levelValue);
                    });
                    estimatedRows += uniqueValuesAtLevel.size;
                });
            }

            // Add column totals row
            if (showColumnTotals) {
                estimatedRows += 1;
            }

            // Add header rows
            estimatedRows += headerRowsCount;
            if (tableTitle) estimatedRows += 1;

            // Add pivot header rows
            if (pivotCols.length > 0) {
                const structure = createHeaderStructure(pivotCols, generateAllCombinations(pivotCols));
                const levels = createHeaderLevels(pivotCols, structure);
                estimatedRows += levels.length + (valueCols.length > 1 || metricGroups.length > 0 ? 2 : 1);
            } else {
                estimatedRows += (metricGroups.length > 0 ? 2 : 1); // Account for metric group headers
            }

            if (estimatedRows > MAX_PREVIEW_ROWS) {
                const container = document.getElementById('data-container');
                container.innerHTML = `
            <div style="padding: 30px; text-align: center; border: 2px solid #ffc107; background-color: #fff3cd; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #856404; margin-bottom: 15px;">‚ö†Ô∏è Preview Disabled</h3>
                <p style="color: #856404; font-size: 16px; margin-bottom: 10px;">
                    <strong>Estimated ${estimatedRows.toLocaleString()} rows</strong> in the report.
                </p>
                <p style="color: #856404; margin-bottom: 15px;">
                    Preview is disabled for reports with more than ${MAX_PREVIEW_ROWS.toLocaleString()} rows to improve performance.
                </p>
                <p style="color: #856404; font-weight: 600;">
                    You can still save the configuration and generate the Excel file directly.
                </p>
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 6px;">
                    <p style="color: #495057; margin: 0; font-size: 14px;">
                        <strong>Current Settings:</strong><br>
                        Row Groups: ${groupCols.length} | Column Groups: ${pivotCols.length} | Value Fields: ${valueCols.length}<br>
                        Metric Groups: ${metricGroups.length} | Subtotals: ${showSubtotals ? 'On' : 'Off'} | Row Totals: ${showRowTotals ? 'On' : 'Off'} | Column Totals: ${showColumnTotals ? 'On' : 'Off'}
                    </p>
                </div>
            </div>
        `;
                return;
            }

            // Continue with normal preview generation if under the limit...
            // Off-DOM build
            const frag = document.createDocumentFragment();
            const table = document.createElement('table'); table.id = 'pivot-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            // --- Header Rows ---
            for (let i = 0; i < headerRowsCount; i++) {
                const settings = headerRowSettings[i] || { type: 'text', text: `Header Row ${i + 1}`, column: '', fontColor: '000000', bgColor: 'F8F9FA', textAlign: 'left' };
                let headerText = '';
                if (settings.type === 'text') {
                    headerText = settings.text;
                } else if (settings.type === 'column') {
                    // Initialize headerText first
                    headerText = 'Loading column value...';

                    try {
                        if (settings.column && titleColumnMap[settings.column]) {
                            headerText = cleanDisplayValue(titleColumnMap[settings.column]);
                        } else if (settings.column && fieldRenames[settings.column]) {
                            headerText = cleanDisplayValue(fieldRenames[settings.column]);
                        } else if (settings.column) {
                            // Try to get the first value from the data for this column
                            const firstValue = allData.find(row => row[settings.column]);
                            if (firstValue && firstValue[settings.column]) {
                                headerText = cleanDisplayValue(firstValue[settings.column].toString());
                            } else {
                                headerText = 'No data found for column: ' + settings.column;
                            }
                        } else {
                            headerText = 'No column selected';
                        }
                    } catch (error) {
                        headerText = 'Error loading column value: ' + error.message;
                    }

                } else if (settings.type === 'filters') {
                    // Initialize headerText first
                    headerText = 'Loading filters...';

                    try {
                        const allWorksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                        let worksheet = null;

                        // Use the same robust worksheet finding logic
                        if (currentWorksheetName) {
                            worksheet = allWorksheets.find(w => w.name === currentWorksheetName);
                        }
                        if (!worksheet && currentWorksheet) {
                            worksheet = allWorksheets.find(w => w.name === currentWorksheet);
                        }
                        if (!worksheet && currentWorksheetName) {
                            worksheet = allWorksheets.find(w => w.name.trim() === currentWorksheetName.trim());
                        }
                        if (!worksheet && allWorksheets.length > 0) {
                            worksheet = allWorksheets[0];
                        }

                        if (!worksheet) {
                            headerText = 'No worksheets available';
                        } else {
                            const filters = await worksheet.getFiltersAsync();
                            const display = settings.selectedFilters && settings.selectedFilters.length
                                ? filters.filter(f => settings.selectedFilters.includes(f.fieldName))
                                : filters;
                            const lines = display.map(f => f.filterType === 'categorical'
                                ? `${f.fieldName}: ${f.appliedValues.length ? f.appliedValues.map(v => isNullValue(v.value) ? 'Null' : cleanDisplayValue(v.value)).join(', ') : 'All'}`
                                : '').filter(Boolean);
                            headerText = lines.length ? lines.join('\n') : 'No filters applied';
                        }
                    } catch (error) {
                        headerText = 'Error loading filters: ' + error.message;
                    }

                } else if (settings.type === 'refreshDate') {
                    // Initialize headerText first
                    headerText = 'Loading refresh date...';

                    try {
                        const allWorksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                        let worksheet = null;

                        // Method 1: Try currentWorksheetName
                        if (currentWorksheetName) {
                            worksheet = allWorksheets.find(w => w.name === currentWorksheetName);
                        }

                        // Method 2: Try currentWorksheet if Method 1 failed
                        if (!worksheet && currentWorksheet) {
                            worksheet = allWorksheets.find(w => w.name === currentWorksheet);
                        }

                        // Method 3: Try trimmed versions (remove extra spaces)
                        if (!worksheet && currentWorksheetName) {
                            worksheet = allWorksheets.find(w => w.name.trim() === currentWorksheetName.trim());
                        }

                        // Method 4: Use the first worksheet as fallback
                        if (!worksheet && allWorksheets.length > 0) {
                            worksheet = allWorksheets[0];
                        }

                        if (!worksheet) {
                            headerText = 'No worksheets available';
                        } else {
                            // Found a worksheet, now get the refresh date
                            const dataSources = await worksheet.getDataSourcesAsync();

                            if (dataSources.length === 0) {
                                headerText = 'No data sources available';
                            } else {
                                const ds = dataSources[0];
                                const extractTime = ds.extractUpdateTime;

                                if (!extractTime) {
                                    headerText = 'No refresh time available';
                                } else {
                                    const tz = settings.timeZone || 'UTC';
                                    const fmt = settings.dateFormat ? JSON.parse(settings.dateFormat) : {
                                        year: 'numeric',
                                        month: 'short',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit'
                                    };

                                    const formattedDate = formatDateWithCustomSeparator(new Date(extractTime), fmt, tz);

                                    headerText = (settings.prefixText || '') +
                                        (settings.prefixText && !settings.prefixText.endsWith(' ') ? ' ' : '') +
                                        formattedDate;
                                }
                            }
                        }
                    } catch (error) {
                        // Ultimate fallback - show current date/time with your selected format
                        try {
                            const tz = settings.timeZone || 'UTC';
                            const fmt = settings.dateFormat ? JSON.parse(settings.dateFormat) : {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            };

                            const now = new Date();
                            const formattedDate = formatDateWithCustomSeparator(now, fmt, tz);

                            headerText = (settings.prefixText || '') +
                                (settings.prefixText && !settings.prefixText.endsWith(' ') ? ' ' : '') +
                                formattedDate + ' (current time)';
                        } catch (fallbackError) {
                            headerText = (settings.prefixText || 'Refresh Date: ') + new Date().toLocaleString();
                        }
                    }
                }
                const tr = document.createElement('tr');
                const th = document.createElement('th');
                th.colSpan = groupCols.length + (colKeys.length * valueCols.length) + (showRowTotals ? valueCols.length : 0);
                th.innerHTML = headerText.replace(/\n/g, '<br>');
                th.style.cursor = 'pointer';
                th.onclick = () => configureHeaderRow(i);
                th.style.color = `#${settings.fontColor}`;
                th.style.backgroundColor = `#${settings.bgColor}`;
                th.style.textAlign = settings.textAlign;
                th.style.whiteSpace = 'pre-wrap';
                tr.appendChild(th);
                thead.appendChild(tr);
            }

            // --- Table Title ---
            if (tableTitle) {
                const tr = document.createElement('tr');
                const th = document.createElement('th');
                th.colSpan = groupCols.length + (colKeys.length * valueCols.length) + (showRowTotals ? valueCols.length : 0);
                th.textContent = tableTitle;
                th.className = 'table-title';
                th.style.color = `#${titleFontColor}`;
                th.style.backgroundColor = `#${titleBgColor}`;
                th.style.textAlign = titleAlignment;
                tr.appendChild(th);
                thead.appendChild(tr);
            }

            // --- NEW: Generate metric group headers ---
            const metricHeaders = createMetricGroupHeaders(valueCols, colKeys);

            // --- Column Headers ---
            if (pivotCols.length > 0) {
                const structure = createHeaderStructure(pivotCols, generateAllCombinations(pivotCols));
                const levels = createHeaderLevels(pivotCols, structure);
                const depth = levels.length;

                // Group header row
                const gtr = document.createElement('tr');
                groupCols.forEach(gc => {
                    const th = document.createElement('th');
                    th.textContent = fieldRenames[gc.id] || gc.name;
                    th.rowSpan = depth + (metricHeaders.hasGroups ? 2 : (valueCols.length > 1 ? 1 : 0));
                    applyHeaderStyles(th, 'rowGroups');
                    gtr.appendChild(th);
                });
                levels[0].forEach(cell => {
                    const th = document.createElement('th');
                    th.textContent = cell.value;
                    th.colSpan = (metricHeaders.hasGroups || valueCols.length > 1) ? cell.span * valueCols.length : cell.span;
                    th.classList.add('group-header');
                    applyHeaderStyles(th, 'columnGroups');
                    gtr.appendChild(th);
                });
                if (showRowTotals) {
                    const th = document.createElement('th');
                    th.textContent = rowTotalsLabel;
                    th.rowSpan = depth + (metricHeaders.hasGroups ? 1 : 0);
                    th.colSpan = valueCols.length;
                    th.classList.add('grand-total');
                    applyHeaderStyles(th, 'totals');
                    gtr.appendChild(th);
                }
                thead.appendChild(gtr);

                // Additional levels
                for (let lvl = 1; lvl < levels.length; lvl++) {
                    const tr2 = document.createElement('tr');
                    levels[lvl].forEach(cell => {
                        const th = document.createElement('th');
                        th.textContent = cell.value;
                        th.colSpan = (metricHeaders.hasGroups || valueCols.length > 1) ? cell.span * valueCols.length : cell.span;
                        th.classList.add('group-header');
                        applyHeaderStyles(th, 'columnGroups');
                        tr2.appendChild(th);
                    });
                    thead.appendChild(tr2);
                }

                // NEW: Metric group header row
                if (metricHeaders.hasGroups) {
                    const mgtr = document.createElement('tr');
                    mgtr.classList.add('hierarchical-header');

                    colKeys.forEach(() => {
                        metricHeaders.groupHeaders.forEach(groupHeader => {
                            const th = document.createElement('th');
                            th.textContent = groupHeader.name;
                            th.colSpan = groupHeader.span;
                            if (groupHeader.isGroup) {
                                th.classList.add('metric-group-header-cell');
                            }
                            applyHeaderStyles(th, 'columnGroups');
                            mgtr.appendChild(th);
                        });
                    });

                    if (showRowTotals) {
                        metricHeaders.groupHeaders.forEach(groupHeader => {
                            const th = document.createElement('th');
                            th.textContent = groupHeader.name;
                            th.colSpan = groupHeader.isGroup ? groupHeader.span / (colKeys.length || 1) : 1;
                            if (groupHeader.isGroup) {
                                th.classList.add('metric-group-header-cell');
                            }
                            applyHeaderStyles(th, 'totals');
                            mgtr.appendChild(th);
                        });
                    }
                    thead.appendChild(mgtr);
                }

                // Value header row (individual metrics)
                if (metricHeaders.hasGroups || valueCols.length > 1) {
                    const vtr = document.createElement('tr');
                    vtr.classList.add('metric-subheader');

                    colKeys.forEach(() => valueCols.forEach(vc => {
                        const th = document.createElement('th');
                        th.textContent = fieldRenames[vc.id] || vc.name;
                        applyHeaderStyles(th, 'columnGroups');
                        vtr.appendChild(th);
                    }));
                    if (showRowTotals) {
                        valueCols.forEach(vc => {
                            const th = document.createElement('th');
                            th.textContent = fieldRenames[vc.id] || vc.name;
                            applyHeaderStyles(th, 'totals');
                            vtr.appendChild(th);
                        });
                    }
                    thead.appendChild(vtr);
                }
            } else {
                // No pivot columns case
                const tr = document.createElement('tr');
                groupCols.forEach(gc => {
                    const th = document.createElement('th');
                    th.textContent = fieldRenames[gc.id] || gc.name;
                    th.rowSpan = metricHeaders.hasGroups ? 2 : 1;
                    applyHeaderStyles(th, 'rowGroups');
                    tr.appendChild(th);
                });

                // NEW: Add metric group headers when no pivot columns
                if (metricHeaders.hasGroups) {
                    tr.classList.add('hierarchical-header');
                    metricHeaders.groupHeaders.forEach(groupHeader => {
                        const th = document.createElement('th');
                        th.textContent = groupHeader.name;
                        th.colSpan = groupHeader.isGroup ? groupHeader.span : 1;
                        if (groupHeader.isGroup) {
                            th.classList.add('metric-group-header-cell');
                        }
                        applyHeaderStyles(th, 'columnGroups');
                        tr.appendChild(th);
                    });

                    // ‚Äî‚Äî WITH just one grand‚Äëtotal cell spanning all metrics:
                    if (showRowTotals) {
                        // How many individual metrics do we have?
                        const totalMetrics = metricHeaders.groupHeaders
                            .reduce((sum, gh) => sum + (gh.isGroup ? gh.span : 1), 0);

                        const grandTh = document.createElement('th');
                        grandTh.textContent = rowTotalsLabel || 'Row Totals';
                        grandTh.colSpan = totalMetrics;
                        grandTh.classList.add('grand-total');
                        applyHeaderStyles(grandTh, 'totals');
                        tr.appendChild(grandTh);
                    }

                    thead.appendChild(tr);

                    // Add individual metric headers row
                    const vtr = document.createElement('tr');
                    vtr.classList.add('metric-subheader');
                    valueCols.forEach(vc => {
                        const th = document.createElement('th');
                        th.textContent = fieldRenames[vc.id] || vc.name;
                        applyHeaderStyles(th, 'columnGroups');
                        vtr.appendChild(th);
                    });
                    if (showRowTotals) {
                        valueCols.forEach(vc => {
                            const th = document.createElement('th');
                            th.textContent = fieldRenames[vc.id] || vc.name;
                            applyHeaderStyles(th, 'totals');
                            vtr.appendChild(th);
                        });
                    }
                    thead.appendChild(vtr);
                } else {
                    // Standard headers without grouping
                    valueCols.forEach(vc => {
                        const th = document.createElement('th');
                        th.textContent = fieldRenames[vc.id] || vc.name;
                        applyHeaderStyles(th, 'columnGroups');
                        tr.appendChild(th);
                    });
                    if (showRowTotals) valueCols.forEach(vc => {
                        const th = document.createElement('th');
                        th.textContent = fieldRenames[vc.id] || vc.name;
                        applyHeaderStyles(th, 'totals');
                        tr.appendChild(th);
                    });
                    thead.appendChild(tr);
                }
            }

            frag.appendChild(table);
            table.appendChild(thead);
            table.appendChild(tbody);

            // Build Body Rows & apply multi-rule formatting
            let prevGroupValues = null;
            rowKeys.forEach(rowKey => {
                const values = rowKey.split('|');
                const rowsInGroup = rowKeyToRows.get(rowKey) || [];
                let bgColor = getRowBackgroundColor(values, groupCols);
                for (const r of rowsInGroup) {
                    const val = r[rowFormatSettings.field]?.toString();
                    if (val && rowFormatSettings.rules[val]) {
                        bgColor = rowFormatSettings.rules[val];
                        break;
                    }
                }




                if (showSubtotals && prevGroupValues) {
                    for (let lvl = groupCols.length - 1; lvl >= 0; lvl--) {
                        if (prevGroupValues[lvl] !== values[lvl] && selectedSubtotalLevels.includes(lvl)) {
                            insertSubtotalRow(lvl, groupCols, prevGroupValues, colKeys, valueCols, pivotMap, tbody, null, showRowTotals);
                        }
                    }
                }

                const tr = document.createElement('tr');
                values.forEach((v, i) => {
                    const displayValue = cleanDisplayValue(v);
                    tr.appendChild(createGroupCell(displayValue, groupCols[i].id, bgColor));
                });

                const rowTotal = {};
                valueCols.forEach(v => rowTotal[v.id] = null); // Initialize with null

                colKeys.forEach(colKey => {
                    const mapKey = `${rowKey}>>>${colKey}`;
                    const dataObj = pivotMap.get(mapKey) || {};

                    valueCols.forEach(v => {
                        const rawVal = dataObj[v.id]; // This could be null
                        tr.appendChild(createValueCell(rawVal, v.id, bgColor));

                        // Aggregate row totals properly
                        rowTotal[v.id] = aggregateValues(rowTotal[v.id], rawVal);
                    });
                });

                if (showRowTotals) {
                    valueCols.forEach(v => {
                        const td = createValueCell(rowTotal[v.id], v.id, bgColor);
                        td.classList.add('totals');
                        tr.appendChild(td);
                    });
                }
                tbody.appendChild(tr);
                prevGroupValues = values;
            });

            // Final Subtotals
            if (showSubtotals && prevGroupValues) {
                for (let lvl = groupCols.length - 1; lvl >= 0; lvl--) {
                    if (selectedSubtotalLevels.includes(lvl)) {
                        insertSubtotalRow(lvl, groupCols, prevGroupValues, colKeys, valueCols, pivotMap, tbody, null, showRowTotals);
                    }
                }
            }

            // Column Totals
            if (showColumnTotals) {
                const tr = document.createElement('tr');
                tr.classList.add('grand-total');
                const colTotals = {};

                // Initialize column totals with null
                colKeys.forEach(ck => {
                    colTotals[ck] = {};
                    valueCols.forEach(v => colTotals[ck][v.id] = null);
                });

                // Calculate column totals properly
                for (const [mapKey, dataObj] of pivotMap) {
                    const [rowPart, colPart] = mapKey.split('>>>');
                    valueCols.forEach(v => {
                        colTotals[colPart][v.id] = aggregateValues(colTotals[colPart][v.id], dataObj[v.id]);
                    });
                }

                groupCols.forEach((gc, i) => {
                    const td = document.createElement('td');
                    td.textContent = i === 0 ? columnTotalsLabel : '';
                    applyHeaderStyles(td, 'rowGroups');
                    tr.appendChild(td);
                });

                colKeys.forEach(ck => valueCols.forEach(v => {
                    const td = createValueCell(colTotals[ck][v.id], v.id);
                    td.classList.add('grand-total');
                    tr.appendChild(td);
                }));

                if (showRowTotals) {
                    valueCols.forEach(v => {
                        let grandTotal = null;
                        colKeys.forEach(ck => {
                            grandTotal = aggregateValues(grandTotal, colTotals[ck][v.id]);
                        });
                        const td = createValueCell(grandTotal, v.id);
                        td.classList.add('grand-total');
                        tr.appendChild(td);
                    });
                }
                tbody.appendChild(tr);
            }

            // Render
            const container = document.getElementById('data-container');
            container.innerHTML = '';
            container.appendChild(frag);
        }

        function insertSubtotalRow(level, groupCols, currentGroupValues, colKeys, valueCols, pivotMap, tbody, referenceRow, showRowTotals) {
            const subtotalRow = document.createElement('tr');
            subtotalRow.classList.add('subtotal-row');

            const rowBgColor = getRowBackgroundColor(currentGroupValues, groupCols, level);

            groupCols.forEach((gc, index) => {
                const td = document.createElement('td');
                if (index === level) {
                    // PATCH: Show only custom label or group value + "Subtotal"
                    if (useCustomSubtotalLabels && subtotalLabels[level]) {
                        td.textContent = subtotalLabels[level];
                    } else {
                        const groupVal = cleanDisplayValue(currentGroupValues[level]);
                        td.textContent = `${groupVal} Subtotal`;
                    }
                    td.style.fontWeight = 'bold';
                } else if (index < level) {
                    td.textContent = cleanDisplayValue(currentGroupValues[index]);
                } else {
                    td.textContent = '';
                }
                td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${headerFormatSettings.subtotals?.bgColor || 'F8F9FA'}`;
                subtotalRow.appendChild(td);
            });

            colKeys.forEach(colKey => {
                valueCols.forEach(v => {
                    const groupPrefix = currentGroupValues.slice(0, level + 1).join('|');

                    // Proper subtotal aggregation
                    let subtotalValue = null;
                    for (const [key, data] of pivotMap) {
                        const [rowPart, colPart] = key.split('>>>');
                        if (rowPart.startsWith(groupPrefix) && colPart === colKey) {
                            subtotalValue = aggregateValues(subtotalValue, data[v.id]);
                        }
                    }

                    const td = createValueCell(subtotalValue, v.id, rowBgColor);
                    td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${headerFormatSettings.subtotals?.bgColor || 'F8F9FA'}`;
                    subtotalRow.appendChild(td);
                });
            });

            if (showRowTotals) {
                valueCols.forEach(v => {
                    const groupPrefix = currentGroupValues.slice(0, level + 1).join('|');

                    // Proper row total aggregation
                    let rowTotal = null;
                    for (const [key, data] of pivotMap) {
                        const [rowPart] = key.split('>>>');
                        if (rowPart.startsWith(groupPrefix)) {
                            rowTotal = aggregateValues(rowTotal, data[v.id]);
                        }
                    }

                    const td = createValueCell(rowTotal, v.id, rowBgColor);
                    td.classList.add('subtotal');
                    td.style.backgroundColor = rowBgColor ? `#${rowBgColor}` : `#${headerFormatSettings.subtotals?.bgColor || 'F8F9FA'}`;
                    td.style.fontWeight = 'bold';
                    subtotalRow.appendChild(td);
                });
            }

            tbody.insertBefore(subtotalRow, referenceRow ? referenceRow.nextSibling : null);
        }

        document.addEventListener("DOMContentLoaded", async () => {
            try {
                await tableau.extensions.initializeDialogAsync();
                populateTimeZones();
                await initWorksheetSelector();
                // Removed any unconditional fetchWorksheetData()/loadConfiguration() here.
                document.getElementById('generate-btn').addEventListener('click', async () => {
                    if (exportMode === 'datadump') {
                        generateDataDumpPreview();
                    } else {
                        generatePivotTable();
                    }
                });
                document.getElementById('save-btn').addEventListener('click', saveConfiguration);

                document.getElementById('format-type').addEventListener('change', (e) => {
                    document.getElementById('currency-symbol-container').style.display = e.target.value === 'currency' ? 'flex' : 'none';
                    document.getElementById('decimals-container').style.display = ['number', 'currency', 'percentage'].includes(e.target.value) ? 'flex' : 'none';
                    document.getElementById('date-format-container').style.display = e.target.value === 'date' ? 'flex' : 'none';
                });

                document.getElementById('table-title').addEventListener('change', (e) => {
                    tableTitle = e.target.value;
                    document.getElementById('title-column').value = '';
                    generatePivotTable(false);
                });

                document.getElementById('title-column').addEventListener('change', (e) => {
                    if (e.target.value) {
                        tableTitle = titleColumnMap[e.target.value] || '';
                        document.getElementById('table-title').value = '';
                    }
                    generatePivotTable(false);
                });

                document.getElementById('title-font-color').addEventListener('input', (e) => {
                    titleFontColor = e.target.value.replace('#', '');
                    generatePivotTable(false);
                });

                document.getElementById('title-bg-color').addEventListener('input', (e) => {
                    titleBgColor = e.target.value.replace('#', '');
                    generatePivotTable(false);
                });

                document.getElementById('title-alignment').addEventListener('change', (e) => {
                    titleAlignment = e.target.value;
                    generatePivotTable(false);
                });

                ['show-subtotals', 'show-row-totals', 'show-column-totals'].forEach(id => {
                    // document.getElementById(id).addEventListener('change', generatePivotTable);
                });

                // PATCH: Add event listener for subtotal level changes to update labels UI
                document.getElementById('subtotal-level-select').addEventListener('change', () => {
                    if (useCustomSubtotalLabels) {
                        updateSubtotalLabelsUI();
                    }
                });

                document.getElementById('workbook-file-name').addEventListener('input', (e) => {
                    document.getElementById('excel-file-name-field').value = '';
                });

                document.getElementById('excel-file-name-field').addEventListener('change', (e) => {
                    if (e.target.value) {
                        document.getElementById('workbook-file-name').value = '';
                    }
                });

                populateRowFormatFields();
                document.getElementById('row-format-field').addEventListener('change', updateRowFormatValueSelector);

                // Export mode radio button listeners
                document.querySelectorAll('input[name="export-mode"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        switchExportMode(e.target.value);
                    });
                });

                // Initialize metric groups
                renderMetricGroups();
                updateNoGroupsMessage();

            } catch (error) {
                console.error('Initialization error:', error);
                alert('Initialization failed: ' + error.message);
            }
        });
    </script>
</body>

</html>