<!DOCTYPE html>
<html>

<head>
    <script src="https://working-extension-excel.vercel.app/lib/tableau.extensions.1.latest.js"></script>
    <script src="https://working-extension-excel.vercel.app/lib/exceljs.min.js"></script>
    <script src="https://working-extension-excel.vercel.app/lib/jszip.min.js"></script>
    <title>Pivot Table Generator</title>
    <style>
        :root {
            --primary-blue: #0056b3; 
            --primary-blue-dark: #003d7e;
            --text-color: #333333;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: transparent !important;
            color: var(--text-color);
            line-height: 1.6;
            overflow: hidden;
        }

        img#export-btn {
            max-width: 90%;
            max-height: 90vh;
            height: auto;
            width: auto;
            object-fit: contain;
            padding: 0;
            border-radius: 0;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
            background-color: transparent;
            box-shadow: none;
        }

        img#export-btn:hover {
            transform: scale(1.05);
            opacity: 0.9;
        }

        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: var(--primary-blue);
            font-size: 1.2em;
            font-weight: bold;
        }

        .spinner {
            border: 0.5vw solid rgba(0, 0, 0, 0.1);
            border-top: 0.5vw solid var(--primary-blue);
            border-radius: 50%;
            width: 8vw;
            height: 8vw;
            max-width: 80px;
            max-height: 80px;
            min-width: 30px;
            min-height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #progress-info {
            margin-top: 20px;
            font-size: 0.9em;
            color: #666;
        }

        #progress-bar {
            width: 300px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }

        #progress-fill {
            height: 100%;
            background: var(--primary-blue);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>

<body>
    <img id="export-btn" src="https://abhishekraoep.github.io/ExcelExtension/excel-icon.svg" alt="Export to Excel"
        title="Export to Excel">

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-info">Processing data...</div>
    </div>

    <script>
        // Global state
        let allData = [];
        let columns = [];
        let formatSettings = {};
        let fieldRenames = {};
        let headerFormatSettings = {
            rowGroups: { fontColor: '000000', bgColor: 'F1F3F5', textAlign: 'left' },
            columnGroups: { fontColor: '000000', bgColor: 'E9ECEF', textAlign: 'center' },
            totals: { fontColor: '000000', bgColor: 'E9ECEF', textAlign: 'right' },
            subtotals: { fontColor: '000000', bgColor: 'F8F9FA', textAlign: 'left' }
        };
        let headerRowsCount = 0;
        let headerRowSettings = [];
        let tableTitle = '';
        let titleFontColor = '000000';
        let titleBgColor = 'F8F9FA';
        let titleAlignment = 'center';
        let titleColumnMap = {};
        let currentWorksheetName = '';
        let metricGroups = [];
        // PATCH: Subtotal label variables for export
        let subtotalLabels = {};
        let useCustomSubtotalLabels = false;

        // Performance optimization caches
        const formatCache = new Map();
        const conditionCache = new Map();
        const rowColorCache = new Map();

        // Progress tracking
        let totalOperations = 0;
        let completedOperations = 0;

        /* ADD: Zip multiple CSVs and trigger single download */
        async function downloadZip(csvFiles, zipName) {
            // csvFiles: [{ content: '...', fileName: 'name' }, ...]
            try {
                if (typeof JSZip === 'undefined') {
                    // fallback: download individually if JSZip not loaded
                    console.warn('JSZip not found. Falling back to individual CSV downloads.');
                    csvFiles.forEach((csvFile, index) => {
                        setTimeout(() => {
                            downloadCSV(csvFile.content, csvFile.fileName);
                        }, index * 200);
                    });
                    return;
                }

                const zip = new JSZip();
                csvFiles.forEach(f => {
                    const name = (f.fileName && f.fileName.toLowerCase().endsWith('.csv')) ? f.fileName : (f.fileName + '.csv');
                    zip.file(name, f.content);
                });

                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (zipName && zipName.toLowerCase().endsWith('.zip')) ? zipName : (zipName || 'csv_export') + '.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error('Error creating zip:', err);
                // fallback: individual downloads
                csvFiles.forEach((csvFile, index) => {
                    setTimeout(() => {
                        downloadCSV(csvFile.content, csvFile.fileName);
                    }, index * 200);
                });
            }
        }


        // Custom date formatter to handle different separators
        function formatDateWithCustomSeparator(date, formatOptions, timeZone) {
            // Handle custom format styles (dash, dot)
            const formatStyle = formatOptions.formatStyle;
            const cleanOptions = { ...formatOptions };
            delete cleanOptions.formatStyle; // Remove custom property

            if (timeZone) {
                cleanOptions.timeZone = timeZone;
            }

            // Get the formatted date
            let formattedDate = new Intl.DateTimeFormat(undefined, cleanOptions).format(date);

            // Apply custom separators
            if (formatStyle === 'dash') {
                formattedDate = formattedDate.replace(/\//g, '-');
            } else if (formatStyle === 'dot') {
                formattedDate = formattedDate.replace(/\//g, '.');
            }

            // PATCH: Convert am/pm to AM/PM for better formatting
            formattedDate = formattedDate.replace(/\bam\b/gi, 'AM').replace(/\bpm\b/gi, 'PM');

            return formattedDate;
        }

        function showLoading(message = 'Processing data...') {
            document.getElementById('loading-overlay').style.display = 'flex';
            document.getElementById('progress-info').textContent = message;
            updateProgressBar(0);
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            resetProgress();
        }

        function updateProgress(message, progress = null) {
            document.getElementById('progress-info').textContent = message;
            if (progress !== null) {
                updateProgressBar(progress);
            }
        }

        function updateProgressBar(percentage) {
            const fill = document.getElementById('progress-fill');
            fill.style.width = Math.min(100, Math.max(0, percentage)) + '%';
        }

        function resetProgress() {
            totalOperations = 0;
            completedOperations = 0;
            updateProgressBar(0);
        }

        function incrementProgress(message) {
            completedOperations++;
            const percentage = totalOperations > 0 ? (completedOperations / totalOperations) * 100 : 0;
            updateProgress(message, percentage);
        }

        // Async processing helpers
        function sleep(ms = 1) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function processInBatches(items, batchSize, processor, progressMessage = "Processing") {
            const results = [];
            const totalBatches = Math.ceil(items.length / batchSize);

            for (let i = 0; i < items.length; i += batchSize) {
                const batch = items.slice(i, i + batchSize);
                const batchResults = await processor(batch, i);
                results.push(...batchResults);

                // Update progress and yield control
                const batchNumber = Math.floor(i / batchSize) + 1;
                const progress = (batchNumber / totalBatches) * 100;
                updateProgress(`${progressMessage}: ${Math.round(progress)}%`, progress);

                // Yield control every batch
                await sleep(1);
            }
            return results;
        }

        function cssColorToARGB(cssColor) {
            if (!cssColor) return null;
            cssColor = cssColor.trim();
            if (cssColor.startsWith('#')) {
                let hex = cssColor.slice(1);
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                return 'FF' + hex.toUpperCase();
            }
            const m = cssColor.match(/rgba?\(\s*(\d+),\s*(\d+),\s*(\d+)/i);
            if (m) {
                const r = parseInt(m[1], 10).toString(16).padStart(2, '0');
                const g = parseInt(m[2], 10).toString(16).padStart(2, '0');
                const b = parseInt(m[3], 10).toString(16).padStart(2, '0');
                return 'FF' + r + g + b;
            }
            return null;
        }


        // Convert user-friendly date format to Excel format codes
        function convertToExcelDateFormat(dateFormat) {
            if (!dateFormat) return 'mm/dd/yyyy';
            return dateFormat
                .replace(/YYYY/g, 'yyyy')
                .replace(/YY/g, 'yy')
                .replace(/MMMM/g, 'mmmm')
                .replace(/MMM/g, 'mmm')
                .replace(/MM/g, 'mm')
                .replace(/DD/g, 'dd')
                .replace(/HH/g, 'hh')
                .replace(/ss/g, 'ss');
        }

        // Format date value for display based on user's date format pattern  
        function formatDateWithPattern(date, pattern) {
            const pad = (n) => n.toString().padStart(2, '0');
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const fullMonths = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];

            return pattern
                .replace('YYYY', date.getFullYear())
                .replace('YY', String(date.getFullYear()).slice(-2))
                .replace('MMMM', fullMonths[date.getMonth()])
                .replace('MMM', months[date.getMonth()])
                .replace('MM', pad(date.getMonth() + 1))
                .replace('DD', pad(date.getDate()))
                .replace('HH', pad(date.getHours()))
                .replace('mm', pad(date.getMinutes()))
                .replace('ss', pad(date.getSeconds()));
        }

        // Format a date value according to the configured date format
        function formatDateValue(value, dateFormat) {
            if (!value || isNullValue(value)) return '';

            let dateObj;
            if (value instanceof Date) {
                dateObj = value;
            } else if (typeof value === 'string') {
                dateObj = new Date(value);
            } else if (typeof value === 'number') {
                dateObj = new Date((value - 25569) * 86400 * 1000);
            }

            if (!dateObj || isNaN(dateObj.getTime())) {
                return value.toString();
            }

            return formatDateWithPattern(dateObj, dateFormat);
        }
        // Optimized format string caching
        function getFormatString(columnId, shapePrefix = '') {
            const cacheKey = `${columnId}_${shapePrefix}`;
            if (formatCache.has(cacheKey)) {
                return formatCache.get(cacheKey);
            }

            const settings = formatSettings[columnId] || {};
            const decimals = settings.decimals;
            const fmtType = settings.formatType || 'number';
            const currSym = settings.currencySymbol || '$';

            let formatStr;

            if (fmtType === 'text') {
                formatStr = '@'; // Text format
            } else if (fmtType === 'date') {
                // Date format - convert user format to Excel format codes
                const dateFormat = settings.dateFormat || 'MM/DD/YYYY';
                formatStr = convertToExcelDateFormat(dateFormat);
            } else if (decimals !== null && decimals !== undefined) {
                // User has specified decimal formatting - respect it
                if (decimals === 0) {
                    switch (fmtType) {
                        case 'currency':
                            formatStr = `"${shapePrefix}${currSym}"#,##0`;
                            break;
                        case 'percentage':
                            formatStr = `"${shapePrefix}"0%`;
                            break;
                        default:
                            formatStr = `"${shapePrefix}"#,##0`;
                    }
                } else {
                    switch (fmtType) {
                        case 'currency':
                            formatStr = `"${shapePrefix}${currSym}"#,##0.${'0'.repeat(decimals)}`;
                            break;
                        case 'percentage':
                            formatStr = `"${shapePrefix}"0.${'0'.repeat(decimals)}%`;
                            break;
                        default:
                            formatStr = `"${shapePrefix}"#,##0.${'0'.repeat(decimals)}`;
                    }
                }
            } else {
                // No specific decimal formatting - use format with commas
                switch (fmtType) {
                    case 'currency':
                        formatStr = shapePrefix ? `"${shapePrefix}${currSym}"#,##0.00` : `"${currSym}"#,##0.00`;
                        break;
                    case 'percentage':
                        formatStr = `"${shapePrefix}"0.00%`;
                        break;
                    default:
                        // Use number format with commas
                        formatStr = shapePrefix ? `"${shapePrefix}"#,##0.00` : '#,##0.00';
                }
            }

            formatCache.set(cacheKey, formatStr);
            return formatStr;
        }
        function formatValueForExcel(value, columnId, isTotal = false, headerType = null, row = null) {
            const settings = formatSettings[columnId] || {};
            // PATCH: Use actual decimals from settings, but preserve original precision if not specified
            const decimals = settings.formatType === 'text' ? null : (settings.decimals ?? null);
            const fmtType = settings.formatType || 'number';
            const currSym = settings.currencySymbol || '$';
            let shapePrefix = '';

            // Handle null values first
            if (value === null || value === undefined || isNullValue(value)) {
                return {
                    displayText: '',
                    shapePrefix: '',
                    rawValue: null
                };
            }

            // Check for conditional shape prefix - optimized
            if (!isTotal && settings.conditions) {
                const nv = parseFloat(value);
                for (const cond of settings.conditions) {
                    let cmpVal = cond.compareType === 'field' ? 0 : cond.value;
                    const cv = parseFloat(cmpVal);
                    let met = false;

                    if (cond.operator === '==' && value?.toString() === cmpVal?.toString()) {
                        met = true;
                    } else if (!isNaN(nv) && !isNaN(cv)) {
                        switch (cond.operator) {
                            case '>': met = nv > cv; break;
                            case '<': met = nv < cv; break;
                            case '>=': met = nv >= cv; break;
                            case '<=': met = nv <= cv; break;
                            case '!=': met = nv != cv; break;
                        }
                    }

                    if (met) {
                        shapePrefix = cond.shape || '';
                        break;
                    }
                }
            }

            // Build displayed string
            let baseText;

            // NEW LOGIC: Use formattedValue by default if no specific format is configured
            const hasSpecificFormat = settings.formatType && settings.formatType !== 'text';
            const hasDecimals = settings.decimals !== null && settings.decimals !== undefined;

            if (!hasSpecificFormat && !hasDecimals) {
                // Try to use the formatted value from the row if available
                if (row && row[columnId + '_formatted']) {
                    baseText = row[columnId + '_formatted'];
                } else {
                    baseText = (value ?? '').toString();
                }
                return {
                    displayText: shapePrefix ? (shapePrefix + ' ' + baseText) : baseText,
                    shapePrefix: shapePrefix,
                    rawValue: value
                };
            }
            if (fmtType === 'text') {
                baseText = (value ?? '').toString();
            } else if (fmtType === 'date') {
                // Format date according to user's selected format
                const dateFormat = settings.dateFormat || 'MM/DD/YYYY';
                baseText = formatDateValue(value, dateFormat);
            } else {
                const numValue = parseFloat(value);
                if (isNaN(numValue)) {
                    baseText = (value ?? '').toString();
                } else {
                    // PATCH: Handle decimal formatting properly
                    if (decimals === null || decimals === undefined) {
                        // No specific decimal formatting - preserve original precision
                        switch (fmtType) {
                            case 'currency': baseText = currSym + numValue.toString(); break;
                            case 'percentage': baseText = (numValue * 100).toString() + '%'; break;
                            default: baseText = numValue.toString();
                        }
                    } else if (decimals === 0) {
                        switch (fmtType) {
                            case 'currency': baseText = currSym + Math.round(numValue); break;
                            case 'percentage': baseText = Math.round(numValue * 100) + '%'; break;
                            default: baseText = Math.round(numValue).toString();
                        }
                    } else {
                        switch (fmtType) {
                            case 'currency': baseText = currSym + numValue.toFixed(decimals); break;
                            case 'percentage': baseText = (numValue * 100).toFixed(decimals) + '%'; break;
                            default: baseText = numValue.toFixed(decimals);
                        }
                    }
                }
            }

            return {
                displayText: shapePrefix ? (shapePrefix + ' ' + baseText) : baseText,
                shapePrefix: shapePrefix,
                rawValue: value
            };
        }
        // Optimized condition evaluation with caching
        function evaluateValueConditions(value, columnId) {
            const cacheKey = `${columnId}_${value}`;
            if (conditionCache.has(cacheKey)) {
                return conditionCache.get(cacheKey);
            }

            const settings = formatSettings[columnId] || {};
            let fontColor = settings.fontColor || null;
            let bgColor = settings.bgColor || null;

            if (settings.conditions) {
                const nv = parseFloat(value);
                for (const cond of settings.conditions) {
                    let cmpVal = cond.compareType === 'field' ? 0 : cond.value;
                    const cv = parseFloat(cmpVal);
                    let met = false;

                    if (cond.operator === '==' && value?.toString() === cmpVal?.toString()) {
                        met = true;
                    } else if (!isNaN(nv) && !isNaN(cv)) {
                        switch (cond.operator) {
                            case '>': met = nv > cv; break;
                            case '<': met = nv < cv; break;
                            case '>=': met = nv >= cv; break;
                            case '<=': met = nv <= cv; break;
                            case '!=': met = nv != cv; break;
                        }
                    }

                    if (met) {
                        if (cond.fontColor) fontColor = cond.fontColor;
                        if (cond.bgColor) bgColor = cond.bgColor;
                        break;
                    }
                }
            }

            const result = { fontColor, bgColor };
            conditionCache.set(cacheKey, result);
            return result;
        }

        async function loadAllConfigurations() {
            const saved = tableau.extensions.settings.get('configs');
            return saved ? JSON.parse(saved) : {};
        }

        function parseValueForAggregation(value) {
            // Return null for actual null values, otherwise parse as number
            if (isNullValue(value)) {
                return null;
            }

            // PATCH: If it's already a number, return as-is to preserve precision
            if (typeof value === 'number') {
                return value;
            }

            const cleaned = String(value).replace(/,/g, '');
            const parsed = parseFloat(cleaned);
            // PATCH: Use higher precision and don't truncate decimals
            return isNaN(parsed) ? null : parsed;
        }

        function aggregateValues(existingValue, newValue) {
            // If both values are null, result is null
            if (existingValue === null && newValue === null) {
                return null;
            }

            // If one is null, use the other (treating null as "no contribution")
            if (existingValue === null) {
                return newValue;
            }
            if (newValue === null) {
                return existingValue;
            }

            // PATCH: Ensure both are numbers and preserve precision
            const existing = typeof existingValue === 'number' ? existingValue : parseFloat(existingValue);
            const newVal = typeof newValue === 'number' ? newValue : parseFloat(newValue);

            if (isNaN(existing) || isNaN(newVal)) {
                return existingValue; // Return existing if can't parse
            }

            // Both are numbers, add them with full precision
            return existing + newVal;
        }




        // OPTIMIZED: Async pivot map building with progress tracking
        async function buildPivotMap(config) {
            updateProgress('Building pivot structure...', 0);

            const groupCols = config.groupColumns;
            const pivotCols = config.pivotColumns;
            const valueCols = config.valueColumns;

            console.log('Building pivot matrix with valid row combinations...');

            // Step 1: Get ONLY valid row combinations (that exist in data) - with batching
            updateProgress('Collecting row combinations...', 10);
            const validRowCombos = new Set();
            const pivotValueSets = new Map();
            pivotCols.forEach(pc => {
                pivotValueSets.set(pc.id, new Set());
            });

            // Process data in batches to avoid blocking UI
            const batchSize = 10000;
            for (let i = 0; i < allData.length; i += batchSize) {
                const endIdx = Math.min(i + batchSize, allData.length);

                for (let j = i; j < endIdx; j++) {
                    const row = allData[j];
                    const rowKey = groupCols.map(g => row[g.id] || '').join('|');
                    validRowCombos.add(rowKey);

                    // Collect pivot values
                    pivotCols.forEach(pc => {
                        const val = row[pc.id] || '';
                        pivotValueSets.get(pc.id).add(val);
                    });
                }

                // Update progress and yield control
                if (i % (batchSize * 5) === 0) {
                    const progress = 10 + ((i / allData.length) * 30);
                    updateProgress(`Analyzing data: ${Math.round((i / allData.length) * 100)}%`, progress);
                    await sleep(1);
                }
            }

            // Step 2: Get column combinations preserving order - optimized
            updateProgress('Building column structure...', 40);
            const pivotDimensions = {};
            const allValues = {};

            pivotCols.forEach(pc => {
                pivotDimensions[pc.id] = [];
                allValues[pc.id] = Array.from(pivotValueSets.get(pc.id));
            });

            // Optimized canonical order determination
            if (pivotCols.length > 1) {
                const firstPivotCol = pivotCols[0];
                const groupedByFirst = {};

                // Group data by first pivot column efficiently
                for (let i = 0; i < allData.length; i += 1000) {
                    const endIdx = Math.min(i + 1000, allData.length);
                    for (let j = i; j < endIdx; j++) {
                        const row = allData[j];
                        const firstVal = row[firstPivotCol.id] || '';
                        if (!groupedByFirst[firstVal]) {
                            groupedByFirst[firstVal] = [];
                        }
                        groupedByFirst[firstVal].push(row);
                    }
                }

                // Find the group with the most complete set of values
                let bestOrder = null;
                let maxCompleteness = 0;

                Object.keys(groupedByFirst).forEach(groupKey => {
                    const groupData = groupedByFirst[groupKey];
                    const seenValues = {};
                    pivotCols.slice(1).forEach(pc => {
                        seenValues[pc.id] = new Set();
                    });

                    groupData.forEach(row => {
                        pivotCols.slice(1).forEach(pc => {
                            const val = row[pc.id] || '';
                            seenValues[pc.id].add(val);
                        });
                    });

                    let completeness = 0;
                    pivotCols.slice(1).forEach(pc => {
                        completeness += seenValues[pc.id].size;
                    });

                    if (completeness > maxCompleteness) {
                        maxCompleteness = completeness;
                        const orderForThisGroup = {};

                        pivotCols.forEach(pc => {
                            orderForThisGroup[pc.id] = [];
                        });

                        groupData.forEach(row => {
                            pivotCols.forEach(pc => {
                                const val = row[pc.id] || '';
                                if (!orderForThisGroup[pc.id].includes(val)) {
                                    orderForThisGroup[pc.id].push(val);
                                }
                            });
                        });

                        bestOrder = orderForThisGroup;
                    }
                });

                if (bestOrder) {
                    pivotCols.forEach(pc => {
                        pivotDimensions[pc.id] = [...bestOrder[pc.id]];
                        allValues[pc.id].forEach(val => {
                            if (!pivotDimensions[pc.id].includes(val)) {
                                pivotDimensions[pc.id].push(val);
                            }
                        });
                    });
                } else {
                    pivotCols.forEach(pc => {
                        pivotDimensions[pc.id] = [...allValues[pc.id]];
                    });
                }
            } else {
                pivotCols.forEach(pc => {
                    pivotDimensions[pc.id] = [...allValues[pc.id]];
                });
            }

            console.log('Using canonical order for columns:', pivotDimensions);

            // Generate ALL possible column combinations
            updateProgress('Generating column combinations...', 50);
            function cartesianProductCanonical(dimensions) {
                const keys = Object.keys(dimensions);
                if (keys.length === 0) return [{}];

                const result = [];

                function generate(index, current) {
                    if (index === keys.length) {
                        result.push({ ...current });
                        return;
                    }

                    const currentKey = keys[index];
                    const values = dimensions[currentKey];

                    values.forEach(value => {
                        current[currentKey] = value;
                        generate(index + 1, current);
                    });
                }

                generate(0, {});
                return result;
            }

            const allColCombos = cartesianProductCanonical(pivotDimensions);
            const rowKeys = Array.from(validRowCombos);
            const colKeys = allColCombos.map(combo =>
                pivotCols.map(pc => combo[pc.id] || '').join('|')
            );

            console.log(`Using ${rowKeys.length} valid row combinations and ${colKeys.length} column combinations with canonical order`);

            // Step 3: Create matrix for valid rows Ã— all columns - with batching
            updateProgress('Initializing pivot matrix...', 60);
            const pivotMap = new Map();
            const totalCells = rowKeys.length * colKeys.length;

            // Process in batches to avoid blocking
            const rowBatchSize = 1000;
            for (let r = 0; r < rowKeys.length; r += rowBatchSize) {
                const endRowIdx = Math.min(r + rowBatchSize, rowKeys.length);

                for (let ri = r; ri < endRowIdx; ri++) {
                    for (let c = 0; c < colKeys.length; c++) {
                        const mapKey = `${rowKeys[ri]}>>>${colKeys[c]}`;
                        const cellData = {};
                        valueCols.forEach(v => {
                            cellData[v.id] = null; // Initialize with null instead of 0
                        });
                        metricGroups.forEach(group => {
                            group.fields.forEach(fieldId => {
                                cellData[fieldId] = null;
                            });
                        });
                        pivotMap.set(mapKey, cellData);
                    }
                }

                // Update progress and yield control
                if (r % (rowBatchSize * 10) === 0) {
                    const progress = 60 + ((r / rowKeys.length) * 20);
                    updateProgress(`Initializing matrix: ${Math.round((r / rowKeys.length) * 100)}%`, progress);
                    await sleep(1);
                }
            }

            console.log(`Initialized ${pivotMap.size} cells in pivot matrix`);

            // Step 4: Fill in actual data values - with batching
            updateProgress('Populating pivot data...', 80);
            let populatedCells = 0;

            for (let i = 0; i < allData.length; i += batchSize) {
                const endIdx = Math.min(i + batchSize, allData.length);

                for (let j = i; j < endIdx; j++) {
                    const row = allData[j];
                    const rowKey = groupCols.map(g => row[g.id] || '').join('|');
                    const colKey = pivotCols.map(p => row[p.id] || '').join('|');
                    const mapKey = `${rowKey}>>>${colKey}`;

                    const cellData = pivotMap.get(mapKey);
                    if (cellData) {
                        valueCols.forEach(v => {
                            const rawVal = row[v.id];
                            const parsedValue = parseValueForAggregation(rawVal);

                            // Use proper aggregation logic
                            cellData[v.id] = aggregateValues(cellData[v.id], parsedValue);

                            if (parsedValue !== null && parsedValue !== 0) {
                                populatedCells++;
                            }
                        });
                    }
                }

                // Update progress and yield control
                if (i % (batchSize * 2) === 0) {
                    const progress = 80 + ((i / allData.length) * 15);
                    updateProgress(`Populating data: ${Math.round((i / allData.length) * 100)}%`, progress);
                    await sleep(1);
                }
            }

            console.log(`Populated ${populatedCells} cells with actual data`);
            updateProgress('Pivot structure complete', 95);

            return {
                pivotMap,
                rowKeys,
                colKeys
            };
        }

        async function buildDataDump(config) {
            updateProgress('Processing data dump...', 0);

            headerRowsCount = config.headerRowsCount || 0;
            headerRowSettings = config.headerRowSettings || [];
            tableTitle = config.tableTitle || '';

            // UPDATED: Get selected columns from BOTH Row Groups AND Values sections
            let selectedColumnIds;
            const rowGroupColumns = config.groupColumns ? config.groupColumns.map(col => col.id) : [];
            const valueColumns = config.valueColumns ? config.valueColumns.map(col => col.id) : [];

            // Combine both sections, removing duplicates
            const combinedColumns = [...new Set([...rowGroupColumns, ...valueColumns])];

            if (combinedColumns.length > 0) {
                selectedColumnIds = combinedColumns;
            } else if (config.dataDumpColumns && config.dataDumpColumns.length > 0) {
                // Fallback to legacy dataDumpColumns
                selectedColumnIds = config.dataDumpColumns;
            } else {
                // If nothing is selected, use all columns
                selectedColumnIds = columns.map(col => col.id);
            }

            const filteredColumns = selectedColumnIds
                .map(id => columns.find(c => c.id === id))
                .filter(Boolean);

            // For data dump, process only selected columns
            let orderedColumns = filteredColumns;
            const hasMetricGroups = metricGroups && metricGroups.length > 0 &&
                metricGroups.some(g => g.fields && g.fields.length > 0);

            if (hasMetricGroups) {
                orderedColumns = [];
                const groupedFieldIds = [];

                // First add row group columns (dimensions)
                filteredColumns.forEach(col => {
                    const isInValueSection = valueColumns.some(vc => vc === col.id);
                    if (!isInValueSection) {
                        orderedColumns.push(col);
                    }
                });

                // Then add grouped metrics in order
                metricGroups.forEach(group => {
                    if (group.fields && group.fields.length > 0) {
                        group.fields.forEach(fieldId => {
                            const col = filteredColumns.find(c => c.id === fieldId);
                            if (col) {
                                orderedColumns.push(col);
                                groupedFieldIds.push(fieldId);
                            }
                        });
                    }
                });

                // Finally add ungrouped metrics
                filteredColumns.forEach(col => {
                    const isInValueSection = valueColumns.some(vc => vc === col.id);
                    if (isInValueSection && !groupedFieldIds.includes(col.id)) {
                        orderedColumns.push(col);
                    }
                });
            }

            // For data dump, process only selected columns
            const processedData = allData.map(row => {
                const newRow = {};
                orderedColumns.forEach(col => {
                    const displayName = fieldRenames[col.id] || col.name;
                    let value = row[col.id];

                    // Use formatValueForExcel to handle formatting (including default formattedValue)
                    const formattedResult = formatValueForExcel(value, col.id, false, null, row);
                    newRow[displayName] = formattedResult.displayText;
                    return;
                    // PATCH: Preserve date formatting
                    if (value && typeof value === 'string' && (
                        /\d{1,2}\/\d{1,2}\/\d{2,4}/.test(value) ||
                        /\d{4}-\d{2}-\d{2}/.test(value) ||
                        /\d{1,2}-\w{3}-\d{2,4}/.test(value) ||
                        /\w{3}\s+\d{1,2},?\s+\d{4}/.test(value)
                    )) {
                        // Keep date values exactly as they are
                        newRow[displayName] = value;
                    } else {
                        newRow[displayName] = value;
                    }
                });
                return newRow;
            });
            // Create column definitions with display names and format settings
            const dataDumpColumns = filteredColumns.map(col => {
                const settings = formatSettings[col.id] || {};

                return {
                    id: col.id,
                    name: fieldRenames[col.id] || col.name,
                    displayName: fieldRenames[col.id] || col.name,
                    // Add format information for CSV generation
                    formatType: settings.formatType || 'text',
                    decimals: settings.decimals !== undefined ? settings.decimals : null,
                    currencySymbol: settings.currencySymbol || '',
                    dateFormat: settings.dateFormat || 'MM/DD/YYYY'
                };
            });

            updateProgress('Data dump ready', 100);

            const orderedDumpColumns = orderedColumns.map(col => {
                return dataDumpColumns.find(dc => dc.id === col.id);
            }).filter(Boolean);

            return {
                data: processedData,
                columns: orderedDumpColumns
            };
        }

        async function generateCSV(data, columns, config) {
            updateProgress('Generating CSV content...', 0);

            let csvContent = '';

            // Add header rows first (if configured)
            for (let i = 0; i < headerRowsCount; i++) {
                const s = headerRowSettings[i] || {
                    type: 'text',
                    text: `Header Row ${i + 1}`,
                    column: '',
                    fontColor: '000000',
                    bgColor: 'F8F9FA',
                    textAlign: 'left'
                };

                let text = '';

                if (s.type === 'text') {
                    text = s.text;
                } else if (s.type === 'column') {
                    text = titleColumnMap[s.column] || '';
                } else if (s.type === 'filters') {
                    const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                        .find(w => w.name === currentWorksheetName);
                    if (worksheet) {
                        try {
                            const filters = await worksheet.getFiltersAsync();
                            const displayFilters = s.selectedFilters && s.selectedFilters.length > 0
                                ? filters.filter(f => s.selectedFilters.includes(f.fieldName))
                                : filters;

                            const lines = [];
                            for (const f of displayFilters) {
                                if (f.filterType === 'categorical') {
                                    const fn = f.fieldName;
                                    const av = f.appliedValues;
                                    const valText = av.length === 0 ? 'All' : av.map(x => isNullValue(x.value) ? 'Null' : cleanDisplayValue(x.value)).join(', ');
                                    lines.push(`${fn}: ${valText}`);
                                }
                            }
                            text = lines.length ? lines.join(' | ') : 'No filters applied';
                        } catch (error) {
                            console.error('Error fetching filters for CSV:', error);
                            text = 'Filters: [Error loading filters]';
                        }
                    } else {
                        text = 'Filters: [Worksheet not found]';
                    }
                } else if (s.type === 'refreshDate') {
                    const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                        .find(w => w.name === currentWorksheetName);
                    if (worksheet) {
                        try {
                            const dataSources = await worksheet.getDataSourcesAsync();
                            const ds = dataSources[0];
                            const extractTime = ds ? ds.extractUpdateTime : undefined;

                            if (extractTime) {
                                try {
                                    const tzInput = s.timeZone || 'UTC';
                                    let formatOpts = s.dateFormat
                                        ? JSON.parse(s.dateFormat)
                                        : {
                                            year: 'numeric',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        };
                                    text = formatDateWithCustomSeparator(new Date(extractTime), formatOpts, tzInput);
                                    if (s.prefixText) {
                                        text = s.prefixText + ' ' + text;
                                    }
                                } catch (e) {
                                    text = new Date(extractTime).toUTCString();
                                }
                            } else {
                                text = 'Data refresh time not available';
                            }
                        } catch (error) {
                            console.error('Error fetching refresh date for CSV:', error);
                            text = 'Data refresh time: [Error loading]';
                        }
                    } else {
                        text = 'Data refresh time: [Worksheet not found]';
                    }
                }

                // Escape CSV and add as first row
                if (text.includes(',') || text.includes('"') || text.includes('\n')) {
                    text = `"${text.replace(/"/g, '""')}"`;
                }

                const headerRowCells = [text];
                for (let j = 1; j < columns.length; j++) {
                    headerRowCells.push('');
                }
                csvContent += headerRowCells.join(',') + '\n';
            }

            // Add table title if it exists
            if (tableTitle) {
                let title = tableTitle;
                if (title.includes(',') || title.includes('"') || title.includes('\n')) {
                    title = `"${title.replace(/"/g, '""')}"`;
                }

                const titleRowCells = [title];
                for (let j = 1; j < columns.length; j++) {
                    titleRowCells.push('');
                }
                csvContent += titleRowCells.join(',') + '\n';
            }

            updateProgress('Creating column headers with width optimization...', 10);

            updateProgress('Creating column headers with width optimization...', 10);

            const columnWidths = [];

            // Check if we have metric groups configured
            const hasMetricGroups = metricGroups && metricGroups.length > 0 &&
                metricGroups.some(g => g.fields && g.fields.length > 0);

            if (hasMetricGroups) {
                // TWO-ROW HEADER for metric grouping

                // Build group header row (Row 1)
                const groupHeaders = [];
                const metricHeaders = [];

                columns.forEach((col, index) => {
                    const displayName = fieldRenames[col.id] || col.name;

                    // Calculate column width
                    let maxWidth = displayName.length;
                    const sampleSize = Math.min(100, data.length);
                    for (let i = 0; i < sampleSize; i++) {
                        const value = data[i][displayName] || '';
                        maxWidth = Math.max(maxWidth, value.toString().length);
                    }
                    const optimizedWidth = Math.min(50, Math.max(10, maxWidth + 2));
                    columnWidths.push(optimizedWidth);

                    // Find which group this column belongs to
                    let groupName = '';
                    for (const group of metricGroups) {
                        if (group.fields && group.fields.includes(col.id)) {
                            groupName = group.name;
                            break;
                        }
                    }

                    // Escape CSV values
                    const escapedGroupName = groupName && (groupName.includes(',') || groupName.includes('"') || groupName.includes('\n'))
                        ? `"${groupName.replace(/"/g, '""')}"`
                        : groupName;
                    const escapedMetricName = (displayName.includes(',') || displayName.includes('"') || displayName.includes('\n'))
                        ? `"${displayName.replace(/"/g, '""')}"`
                        : displayName;

                    groupHeaders.push(escapedGroupName);
                    metricHeaders.push(escapedMetricName);
                });

                // Add both header rows
                csvContent += groupHeaders.join(',') + '\n';
                csvContent += metricHeaders.join(',') + '\n';

            } else {
                // SINGLE-ROW HEADER (backward compatible)
                const headers = columns.map((col, index) => {
                    const displayName = fieldRenames[col.id] || col.name;

                    let maxWidth = displayName.length;

                    const sampleSize = Math.min(100, data.length);
                    for (let i = 0; i < sampleSize; i++) {
                        const value = data[i][displayName] || '';
                        maxWidth = Math.max(maxWidth, value.toString().length);
                    }

                    const optimizedWidth = Math.min(50, Math.max(10, maxWidth + 2));
                    columnWidths.push(optimizedWidth);

                    if (displayName.includes(',') || displayName.includes('"') || displayName.includes('\n')) {
                        return `"${displayName.replace(/"/g, '""')}"`;
                    }
                    return displayName;
                });

                csvContent += headers.join(',') + '\n';
            }

            // NEW: Initialize grand totals tracking for Values fields only
            const grandTotals = {};
            const numericColumns = new Set();

            // Get Values fields from the current configuration
            // The config is passed to this function and contains the valueColumns array
            const valueColumns = config.valueColumns || [];
            const valueFieldIds = valueColumns.map(col => col.id);

            console.log('DEBUG: Value field IDs for totals:', valueFieldIds);

            // Identify numeric columns from Values fields only
            columns.forEach(col => {
                // Only consider columns that are in the Values section
                if (!valueFieldIds.includes(col.id)) {
                    return;
                }

                const settings = formatSettings[col.id] || {};
                // FIXED: Consider a field numeric if it has format type number/currency/percentage OR has decimals setting
                const isNumeric = settings.formatType === 'number' ||
                    settings.formatType === 'currency' ||
                    settings.formatType === 'percentage' ||
                    (settings.decimals !== null && settings.decimals !== undefined);

                if (isNumeric) {
                    numericColumns.add(col.id);
                    grandTotals[col.id] = 0;
                    console.log('DEBUG: Added numeric Values column:', col.id, col.name);
                }
            });

            // If no numeric columns found in format settings, try to detect them from data (Values fields only)
            if (numericColumns.size === 0) {
                console.log('DEBUG: No numeric columns from settings, analyzing Values fields in data...');
                data.slice(0, 100).forEach((row, rowIndex) => {
                    columns.forEach(col => {
                        // Only analyze Values fields
                        if (!valueFieldIds.includes(col.id)) {
                            return;
                        }

                        const displayName = fieldRenames[col.id] || col.name;
                        const value = row[displayName];
                        if (value !== null && value !== undefined && !isNullValue(value)) {
                            // PATCH: Only consider it numeric if it's actually a pure number
                            const valueStr = value.toString().trim();
                            const numValue = parseFloat(valueStr);
                            // Check if the string representation equals the parsed number (no extra characters)
                            if (!isNaN(numValue) && isFinite(numValue) && valueStr === numValue.toString()) {
                                if (!numericColumns.has(col.id)) {
                                    numericColumns.add(col.id);
                                    grandTotals[col.id] = 0;
                                    console.log('DEBUG: Auto-detected numeric Values column:', col.id, col.name, 'from value:', value, 'in row:', rowIndex);
                                }
                            }
                        }
                    });
                });
            }

            console.log('DEBUG: Final numeric Values columns:', Array.from(numericColumns));
            console.log('DEBUG: Initial grand totals:', grandTotals);

            updateProgress('Processing data rows...', 20);

            const batchSize = 10000;
            let processedRows = 0;

            for (let i = 0; i < data.length; i += batchSize) {
                const batch = data.slice(i, i + batchSize);

                batch.forEach((row, batchRowIndex) => {
                    const values = columns.map(col => {
                        const displayName = fieldRenames[col.id] || col.name;
                        let value = row[displayName];

                        if (value === null || value === undefined || isNullValue(value)) {
                            return '';
                        }

                        // Calculate totals for numeric Values columns BEFORE formatting
                        if (numericColumns.has(col.id)) {
                            const numValue = parseFloat(value);
                            if (!isNaN(numValue) && isFinite(numValue)) {
                                grandTotals[col.id] += numValue;
                                if (processedRows < 5) {
                                    console.log(`DEBUG: Adding ${numValue} to Values column ${col.id}, new total: ${grandTotals[col.id]}`);
                                }
                            }
                        }

                        const settings = formatSettings[col.id] || {};
                        const decimals = settings.decimals;
                        const formatType = settings.formatType || 'text'; // MOVED: Define formatType here
                        const currencySymbol = settings.currencySymbol || '$';

                        // PATCH: Special handling for date-like values (MOVED after formatType definition)
                        const isDateLike = value && typeof value === 'string' && (
                            /^\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}$/.test(value) ||    // DD-MM-YYYY or MM/DD/YYYY
                            /^\d{4}[-\/]\d{1,2}[-\/]\d{1,2}$/.test(value) ||      // YYYY-MM-DD
                            /^\d{1,2}-\w{3}-\d{2,4}$/.test(value) ||              // DD-MMM-YYYY
                            /^\w{3}\s+\d{1,2},?\s+\d{4}$/.test(value) ||          // Month DD, YYYY
                            value.includes('GMT') || value.includes('IST')         // Catch any remaining datetime strings
                        );

                        if (isDateLike) {
                            // For date-like values, preserve exactly as formatted by Tableau
                            value = value.toString();
                        } else if (formatType === 'text') {
                            // For text format, preserve the original value exactly
                            value = value.toString();
                        } else if (typeof decimals === 'number') {
                            const numValue = parseFloat(value);
                            if (!isNaN(numValue)) {
                                let formattedValue;

                                if (decimals === 0) {
                                    formattedValue = Math.round(numValue).toString();
                                } else {
                                    formattedValue = numValue.toFixed(decimals);
                                }

                                if (formatType === 'currency') {
                                    value = currencySymbol + formattedValue;
                                } else if (formatType === 'percentage') {
                                    const percentValue = (numValue * 100).toFixed(decimals || 2);
                                    value = percentValue + '%';
                                } else {
                                    value = formattedValue;
                                }
                            } else {
                                // Not a valid number, keep as text
                                value = value.toString();
                            }
                        } else {
                            // No specific decimals set, only format if explicitly numeric format type
                            if (formatType === 'number' || formatType === 'currency' || formatType === 'percentage') {
                                const numValue = parseFloat(value);
                                if (!isNaN(numValue)) {
                                    if (formatType === 'currency') {
                                        value = currencySymbol + numValue.toFixed(2);
                                    } else if (formatType === 'percentage') {
                                        value = (numValue * 100).toFixed(2) + '%';
                                    } else {
                                        value = numValue.toString();
                                    }
                                } else {
                                    // Not a valid number, keep as text
                                    value = value.toString();
                                }
                            } else {
                                // Default: preserve as text
                                value = value.toString();
                            }
                        }

                        if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                            value = `"${value.replace(/"/g, '""')}"`;
                        }

                        return value;
                    });

                    csvContent += values.join(',') + '\n';
                    processedRows++;
                });

                const progress = 20 + ((i + batchSize) / data.length) * 60;
                updateProgress(`Processing CSV: ${Math.round(((i + batchSize) / data.length) * 100)}%`, progress);
            }

            console.log('DEBUG: Final grand totals after processing:', grandTotals);
            console.log('DEBUG: Number of numeric Values columns:', numericColumns.size);

            updateProgress('Adding grand totals...', 80);

            // Add grand totals row if we have numeric Values columns
            if (numericColumns.size > 0) {
                console.log('DEBUG: Adding grand totals row for Values columns...');

                csvContent += '\n';

                const totalsRow = columns.map((col, index) => {
                    if (index === 0) {
                        const label = config.columnTotalsLabel || 'Grand Total';
                        console.log('DEBUG: Using total label:', label);
                        return label.includes(',') || label.includes('"') ? `"${label.replace(/"/g, '""')}"` : label;
                    }

                    // Only add totals for Values columns that are numeric
                    if (numericColumns.has(col.id)) {
                        const totalValue = grandTotals[col.id];
                        console.log(`DEBUG: Formatting total for Values column ${col.id}: ${totalValue}`);

                        const settings = formatSettings[col.id] || {};
                        const decimals = settings.decimals;
                        const formatType = settings.formatType || 'number';
                        const currencySymbol = settings.currencySymbol || '$';

                        let formattedTotal;
                        if (typeof decimals === 'number') {
                            if (decimals === 0) {
                                formattedTotal = Math.round(totalValue).toString();
                            } else {
                                formattedTotal = totalValue.toFixed(decimals);
                            }
                        } else {
                            formattedTotal = totalValue.toString();
                        }

                        let finalTotal;
                        if (formatType === 'currency') {
                            finalTotal = currencySymbol + formattedTotal;
                        } else if (formatType === 'percentage') {
                            finalTotal = formattedTotal + '%';
                        } else {
                            finalTotal = formattedTotal;
                        }

                        console.log(`DEBUG: Final formatted total for Values column ${col.id}: ${finalTotal}`);
                        return finalTotal;
                    }

                    // Non-Values columns or non-numeric Values columns get empty values in totals row
                    return '';
                });

                console.log('DEBUG: Complete totals row:', totalsRow);
                csvContent += totalsRow.join(',') + '\n';
            } else {
                console.log('DEBUG: No numeric Values columns found, skipping totals row');
            }

            updateProgress('CSV generation complete', 100);
            return {
                content: csvContent,
                columnWidths: columnWidths
            };
        }

        function downloadCSV(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = fileName.endsWith('.csv') ? fileName : fileName + '.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Create metric group header structure for Excel
        function createMetricGroupHeaders(valueCols, colKeys) {
            if (!metricGroups || metricGroups.length === 0) {
                return {
                    hasGroups: false,
                    headers: valueCols.map(v => ({
                        name: fieldRenames[v.id] || v.name,
                        span: colKeys.length || 1
                    }))
                };
            }

            const groupHeaders = [];
            const subHeaders = [];

            metricGroups.forEach(group => {
                if (group.fields && group.fields.length > 0) {
                    groupHeaders.push({
                        name: group.name,
                        span: group.fields.length * (colKeys.length || 1),
                        isGroup: true
                    });

                    group.fields.forEach(fieldId => {
                        const field = valueCols.find(v => v.id === fieldId);
                        if (field) {
                            subHeaders.push({
                                name: fieldRenames[field.id] || field.name,
                                span: colKeys.length || 1,
                                groupId: group.id,
                                fieldId: field.id
                            });
                        }
                    });
                }
            });

            const groupedFieldIds = metricGroups.flatMap(g => g.fields || []);
            const ungroupedFields = valueCols.filter(v => !groupedFieldIds.includes(v.id));
            const hasActualGroups = metricGroups.some(g => g.fields && g.fields.length > 0);

            ungroupedFields.forEach(field => {
                subHeaders.push({
                    name: fieldRenames[field.id] || field.name,
                    span: colKeys.length || 1,
                    ungrouped: true,
                    fieldId: field.id
                });
            });

            return {
                hasGroups: metricGroups.length > 0,
                hasActualGroups,
                groupHeaders,
                subHeaders,
                ungroupedFields
            };
        }

        // Helper function to estimate column width based on format settings
        function estimateColumnWidthFromFormat(columnId, sampleValues = []) {
            const settings = formatSettings[columnId] || {};
            const decimals = settings.decimals;
            const formatType = settings.formatType || 'number';
            const currencySymbol = settings.currencySymbol || '$';

            let baseWidth = 8; // Minimum for typical numbers

            // Find the largest sample value to estimate digits
            let maxValue = 0;
            sampleValues.forEach(val => {
                if (val !== null && val !== undefined) {
                    const numVal = Math.abs(parseFloat(val));
                    if (!isNaN(numVal)) {
                        maxValue = Math.max(maxValue, numVal);
                    }
                }
            });

            // Estimate integer digits needed
            const integerDigits = maxValue > 0 ? Math.floor(Math.log10(maxValue)) + 1 : 1;
            const commaDigits = Math.floor((integerDigits - 1) / 3); // Number of commas

            if (formatType === 'currency') {
                baseWidth = currencySymbol.length + integerDigits + commaDigits;
                if (decimals !== null && decimals !== undefined) {
                    baseWidth += decimals + 1; // +1 for decimal point
                } else {
                    baseWidth += 3; // Default .00
                }
            } else if (formatType === 'percentage') {
                baseWidth = integerDigits + commaDigits + 1; // +1 for % symbol
                if (decimals !== null && decimals !== undefined) {
                    baseWidth += decimals + 1; // +1 for decimal point
                } else {
                    baseWidth += 3; // Default .00
                }
            } else if (formatType === 'number') {
                baseWidth = integerDigits + commaDigits;
                if (decimals !== null && decimals !== undefined) {
                    baseWidth += decimals + 1; // +1 for decimal point
                } else {
                    baseWidth += 3; // Default .00
                }
            }

            return Math.max(8, baseWidth + 2); // Add padding and ensure minimum
        }

        // Optimized column width computation with precise decimal-aware uniform value column sizing
        function computeColWidths(config, pivotMap, rowKeys, colKeys) {
            const groupCols = config.groupColumns;
            const valueCols = config.valueColumns;
            const showRowTotals = config.showRowTotals;

            const leftCount = groupCols.length;
            const totalValueFields = metricGroups.length > 0
                ? metricGroups.reduce((sum, group) => sum + group.fields.length, 0) +
                valueCols.filter(v => !metricGroups.some(g => g.fields.includes(v.id))).length
                : valueCols.length;

            const pivotCount = colKeys.length * totalValueFields;
            const totalCount = showRowTotals ? totalValueFields : 0;
            const allCols = leftCount + pivotCount + totalCount;
            const colWidths = new Array(allCols).fill(0);

            // Width settings
            const FIXED_WIDTH = 12;
            const MIN_WIDTH = 8;
            const MAX_WIDTH = 25;
            const PADDING = 1;

            // Group columns - dynamic width based on content
            groupCols.forEach((gc, gi) => {
                let maxLen = (fieldRenames[gc.id] || gc.name).length + PADDING;

                // Sample subset for width calculation
                const sampleSize = Math.min(500, rowKeys.length);
                const step = Math.max(1, Math.floor(rowKeys.length / sampleSize));

                for (let i = 0; i < rowKeys.length; i += step) {
                    const txt = (rowKeys[i].split('|')[gi] || '').toString();
                    maxLen = Math.max(maxLen, txt.length + PADDING);
                }

                // Compare with fixed width and apply constraints
                const dynamicWidth = Math.max(maxLen, FIXED_WIDTH);
                colWidths[gi] = Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, dynamicWidth));
            });

            // Calculate ONE uniform width for ALL value columns with precise format estimation
            let uniformValueWidth = FIXED_WIDTH;

            // Sample pivot map data for analysis
            const sampleSize = Math.min(200, pivotMap.size);
            const sampleEntries = Array.from(pivotMap.entries()).slice(0, sampleSize);

            // Enhanced format-aware width calculation
            valueCols.forEach(vc => {
                const headerLength = (fieldRenames[vc.id] || vc.name).length + PADDING;

                // Get sample values for this column
                const sampleValues = [];
                sampleEntries.forEach(([key, dataObj]) => {
                    if (dataObj[vc.id] !== null && dataObj[vc.id] !== undefined) {
                        sampleValues.push(dataObj[vc.id]);
                    }
                });

                const formatWidth = estimateColumnWidthFromFormat(vc.id, sampleValues);
                uniformValueWidth = Math.max(uniformValueWidth, headerLength, formatWidth);
            });

            // Also verify with actual formatted values
            let longestValueLength = 0;
            sampleEntries.forEach(([key, dataObj]) => {
                valueCols.forEach(vc => {
                    const value = dataObj[vc.id];
                    if (value !== null && value !== undefined) {
                        // Format the value to get actual display length
                        const formattedResult = formatValueForExcel(value, vc.id);
                        const displayLength = formattedResult.displayText.length;
                        longestValueLength = Math.max(longestValueLength, displayLength);
                    }
                });
            });

            // Use the maximum of: estimated format width or actual longest value
            uniformValueWidth = Math.max(uniformValueWidth, longestValueLength + PADDING);

            // Apply constraints
            uniformValueWidth = Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, uniformValueWidth));

            console.log(`Precise format-aware uniform width: ${uniformValueWidth}`); // Debug line

            // Apply the SAME width to ALL value columns
            let idx = leftCount;
            for (let c = 0; c < colKeys.length; c++) {
                for (let v = 0; v < totalValueFields; v++) {
                    colWidths[idx++] = uniformValueWidth;
                }
            }

            // Row totals columns - use the same uniform width
            if (showRowTotals) {
                for (let v = 0; v < totalValueFields; v++) {
                    colWidths[idx++] = uniformValueWidth;
                }
            }

            console.log('Final column widths:', colWidths); // Debug line

            return colWidths;
        }

        function getRowBackgroundColor(rowValues, groupCols, maxLevel = null) {
            if (!groupCols.length) return null;
            for (let i = 0; i < groupCols.length && (maxLevel === null || i <= maxLevel); i++) {
                const colId = groupCols[i].id;
                const settings = formatSettings[colId] || {};
                const txt = (rowValues[i] === null || rowValues[i] === undefined) ? '' : rowValues[i].toString();
                if (Array.isArray(settings.conditions)) {
                    for (const cond of settings.conditions) {
                        let met = false;
                        if (cond.operator === '==' && txt === cond.value?.toString()) {
                            met = true;
                        } else if (['>', '<'].includes(cond.operator)) {
                            const nv = parseFloat(txt), cv = parseFloat(cond.value);
                            if (!isNaN(nv) && !isNaN(cv)) {
                                met = cond.operator === '>' ? (nv > cv) : (nv < cv);
                            }
                        }
                        if (met) return cond.bgColor;
                    }
                }
            }
            return null;
        }

        // Optimized row color mapping with caching
        function buildRowColorMap(groupCols, allData, rowKeys, rowFormatSettings) {
            const map = new Map();
            const { field, rules } = rowFormatSettings;
            if (!field || !rules || Object.keys(rules).length === 0) return map;

            // Build index for faster lookups
            const rowIndex = new Map();
            for (let i = 0; i < allData.length; i += 100) {
                const endIdx = Math.min(i + 100, allData.length);
                for (let j = i; j < endIdx; j++) {
                    const row = allData[j];
                    const key = groupCols.map(gc => row[gc.id]).join('|');
                    if (!rowIndex.has(key)) {
                        rowIndex.set(key, row);
                    }
                }
            }

            rowKeys.forEach(rk => {
                const row = rowIndex.get(rk);
                if (row) {
                    const value = row[field]?.toString();
                    if (value && rules[value]) {
                        map.set(rk, rules[value]);
                    }
                }
            });

            return map;
        }

        function getNumberFormat(columnId, shapePrefix = '') {
            return getFormatString(columnId, shapePrefix);
        }

        function applyHeaderStyles(cell, headerType) {
            const s = headerFormatSettings[headerType] || {};
            if (s.fontColor) {
                cell.font = cell.font || {};
                cell.font.color = { argb: `FF${s.fontColor}` };
                cell.font.bold = cell.font.bold || false;
            }
            if (s.bgColor) {
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: `FF${s.bgColor}` }
                };
            }
            cell.alignment = cell.alignment || { vertical: 'middle' };
            cell.alignment.horizontal = s.textAlign || 'left';
        }

        // Generate all unique combinations of pivot-column values
        function generateAllCombinations(pivotCols) {
            if (!pivotCols.length) return [{}];
            const seen = new Set(), combos = [];
            allData.forEach(r => {
                const obj = {};
                pivotCols.forEach(p => obj[p.id] = r[p.id]?.toString() || '');
                const key = JSON.stringify(obj);
                if (!seen.has(key)) {
                    seen.add(key);
                    combos.push(obj);
                }
            });
            return combos;
        }

        // Build hierarchical header structure for multi-level pivot
        function createHeaderStructure(pivotCols, combos) {
            if (!pivotCols.length) return [];
            const fld = pivotCols[0].id;
            const map = new Map();
            combos.forEach(c => {
                const val = c[fld];
                if (!map.has(val)) {
                    map.set(val, {
                        value: val,
                        span: 1,
                        children: pivotCols.length > 1
                            ? createHeaderStructure(pivotCols.slice(1), combos.filter(x => x[fld] === val))
                            : null
                    });
                } else {
                    map.get(val).span++;
                }
            });
            return Array.from(map.values());
        }

        // Convert header structure into 2D array of levels
        function createHeaderLevels(pivotCols, structure, levels = [], depth = 0) {
            if (!structure.length) return levels;
            levels[depth] = levels[depth] || [];
            structure.forEach(g => {
                levels[depth].push({ value: g.value, span: g.span });
                if (g.children) {
                    createHeaderLevels(pivotCols.slice(1), g.children, levels, depth + 1);
                }
            });
            for (let i = depth + 1; i < pivotCols.length; i++) {
                levels[i] = levels[i] || [];
            }
            return levels;
        }

        // OPTIMIZED: Async Excel sheet building with batch processing
        async function buildExcelSheet(ws, config, pivotMap, rowKeys, colKeys, rowColorMap) {
            updateProgress('Building Excel sheet structure...', 0);

            const groupCols = config.groupColumns;
            const pivotCols = config.pivotColumns;
            const valueCols = config.valueColumns;
            const showRowTotals = config.showRowTotals;
            const showColumnTotals = config.showColumnTotals;
            const showSubtotals = config.showSubtotals;
            const selectedSubtotalLevels = (config.selectedSubtotalLevels || []).map(l => parseInt(l, 10));

            metricGroups = config.metricGroups || [];
            const metricHeaders = createMetricGroupHeaders(valueCols, colKeys);
            const headerHeight = calculateMaxHeaderHeight(groupCols, pivotCols, valueCols, colKeys, metricHeaders, config);

            // Set column widths
            const colWidths = computeColWidths(config, pivotMap, rowKeys, colKeys);
            ws.columns = colWidths.map((width, idx) => ({
                width: width,
                key: idx + 1
            }));

            let currentRow = 1;

            // Helper functions
            function calculateWrappedTextHeight(text, columnWidth, fontSize = 11) {
                if (!text) return 1;

                // Convert text to string and handle line breaks
                const textStr = text.toString();
                const lines = textStr.split('\n');
                let totalLines = 0;

                // Character width estimation based on font size
                const avgCharWidth = fontSize * 0.6;
                const maxCharsPerLine = Math.floor((columnWidth * 7) / avgCharWidth);

                lines.forEach(line => {
                    if (line.length === 0) {
                        totalLines += 1; // Empty line still takes space
                    } else {
                        const wrappedLines = Math.ceil(line.length / maxCharsPerLine);
                        totalLines += wrappedLines;
                    }
                });

                return Math.max(1, totalLines);
            }

            function calculateMaxHeaderHeight(groupCols, pivotCols, valueCols, colKeys, metricHeaders, config) {
                let maxHeight = 1;
                const baseRowHeight = 20;

                // Sample column widths for calculation (use actual widths if available)
                const sampleWidths = {
                    group: 15,    // Average group column width
                    pivot: 20,    // Average pivot column width  
                    value: 15     // Average value column width
                };

                // Check group column headers
                groupCols.forEach(gc => {
                    const text = fieldRenames[gc.id] || gc.name;
                    const lines = calculateWrappedTextHeight(text, sampleWidths.group);
                    maxHeight = Math.max(maxHeight, lines);
                });

                // Check pivot column values
                colKeys.forEach(ck => {
                    const parts = ck.split('|');
                    parts.forEach(part => {
                        const lines = calculateWrappedTextHeight(part, sampleWidths.pivot);
                        maxHeight = Math.max(maxHeight, lines);
                    });
                });

                // Check value column headers
                valueCols.forEach(vc => {
                    const text = fieldRenames[vc.id] || vc.name;
                    const lines = calculateWrappedTextHeight(text, sampleWidths.value);
                    maxHeight = Math.max(maxHeight, lines);
                });

                // Check metric group headers if present
                if (metricHeaders.hasGroups) {
                    metricHeaders.groupHeaders.forEach(gh => {
                        const lines = calculateWrappedTextHeight(gh.name, sampleWidths.value);
                        maxHeight = Math.max(maxHeight, lines);
                    });
                }

                // Check row totals text
                const rowTotalsText = config.rowTotalsLabel || 'Row Totals';
                const lines = calculateWrappedTextHeight(rowTotalsText, sampleWidths.value);
                maxHeight = Math.max(maxHeight, lines);

                // Convert lines to actual row height (minimum 25, maximum 150)
                const calculatedHeight = Math.max(20, Math.min(120, maxHeight * baseRowHeight + 5));
                return calculatedHeight;
            }

            function applyBorder(cell) {
                cell.border = {
                    top: { style: 'thin', color: { argb: 'FF808080' } },
                    left: { style: 'thin', color: { argb: 'FF808080' } },
                    bottom: { style: 'thin', color: { argb: 'FF808080' } },
                    right: { style: 'thin', color: { argb: 'FF808080' } }
                };
            }

            // Custom header rows processing
            updateProgress('Adding custom headers...', 5);
            for (let i = 0; i < headerRowsCount; i++) {
                const s = headerRowSettings[i] || {
                    type: 'text',
                    text: `Header Row ${i + 1}`,
                    column: '',
                    fontColor: '000000',
                    bgColor: 'F8F9FA',
                    textAlign: 'left'
                };

                let text = '';

                if (s.type === 'text') {
                    text = s.text;
                } else if (s.type === 'column') {
                    text = titleColumnMap[s.column] || '';
                } else if (s.type === 'filters') {
                    const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                        .find(w => w.name === currentWorksheetName);
                    if (worksheet) {
                        const filters = await worksheet.getFiltersAsync();
                        const displayFilters = s.selectedFilters && s.selectedFilters.length > 0
                            ? filters.filter(f => s.selectedFilters.includes(f.fieldName))
                            : filters;

                        const lines = [];
                        for (const f of displayFilters) {
                            if (f.filterType === 'categorical') {
                                const fn = f.fieldName;
                                const av = f.appliedValues;
                                const valText = av.length === 0 ? 'All' : av.map(x => isNullValue(x.value) ? 'Null' : cleanDisplayValue(x.value)).join(', ');
                                lines.push(`${fn}: ${valText}`);
                            }
                        }
                        text = lines.join('\n');
                    } else {
                        text = 'Worksheet not found';
                    }
                } else if (s.type === 'refreshDate') {
                    const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                        .find(w => w.name === currentWorksheetName);
                    const dataSources = worksheet ? await worksheet.getDataSourcesAsync() : [];
                    const ds = dataSources[0];
                    const extractTime = ds ? ds.extractUpdateTime : undefined;

                    if (extractTime) {
                        try {
                            const tzInput = s.timeZone || 'UTC';
                            let formatOpts = s.dateFormat
                                ? JSON.parse(s.dateFormat)
                                : {
                                    year: 'numeric',
                                    month: 'short',
                                    day: 'numeric',
                                    hour: '2-digit',
                                    minute: '2-digit'
                                };
                            text = formatDateWithCustomSeparator(new Date(extractTime), formatOpts, tzInput);
                            if (s.prefixText) {
                                text = s.prefixText + ' ' + text;
                            }
                        } catch (e) {
                            text = new Date(extractTime).toUTCString();
                        }
                    } else {
                        text = 'â€”';
                    }
                }

                const row = ws.getRow(currentRow);
                const cell = row.getCell(1);
                cell.value = text;
                cell.alignment = {
                    vertical: 'middle',
                    horizontal: s.textAlign,
                    wrapText: true
                };
                cell.font = {
                    color: { argb: `FF${s.fontColor}` },
                    bold: true
                };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: `FF${s.bgColor}` }
                };
                applyBorder(cell);

                const span = groupCols.length + (colKeys.length * valueCols.length) + (showRowTotals ? valueCols.length : 0);
                ws.mergeCells(currentRow, 1, currentRow, span);
                const textLines = calculateWrappedTextHeight(text, 50);
                row.height = Math.max(20, Math.min(80, textLines * 16 + 6));
                currentRow++;
            }

            // Table title
            if (tableTitle) {
                const row = ws.getRow(currentRow);
                const cell = row.getCell(1);
                cell.value = tableTitle;
                cell.font = {
                    bold: true,
                    color: { argb: `FF${titleFontColor}` }
                };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: `FF${titleBgColor}` }
                };
                cell.alignment = {
                    vertical: 'middle',
                    horizontal: titleAlignment,
                    wrapText: true
                };
                applyBorder(cell);

                const span = groupCols.length + (colKeys.length * valueCols.length) + (showRowTotals ? valueCols.length : 0);
                ws.mergeCells(currentRow, 1, currentRow, span);
                row.height = headerHeight;
                currentRow++;
            }

            // Build headers efficiently
            updateProgress('Building headers...', 15);

            if (pivotCols.length > 0) {
                const combos = colKeys.map(colKey => {
                    const parts = colKey.split('|');
                    const obj = {};
                    pivotCols.forEach((pc, i) => {
                        obj[pc.id] = parts[i] || '';
                    });
                    return obj;
                });
                const structure = createHeaderStructure(pivotCols, combos);
                const levels = createHeaderLevels(pivotCols, structure);
                const depth = levels.length;

                let totalHeaderRows = depth;
                if (metricHeaders.hasGroups) {
                    totalHeaderRows += 1;
                }
                if (valueCols.length > 1 || metricHeaders.hasGroups) {
                    totalHeaderRows += 1;
                }

                const totalPivotColumns = colKeys.length * valueCols.length;

                // Group columns headers
                const firstHeaderRow = ws.getRow(currentRow);
                let colIndex = 1;

                groupCols.forEach(gc => {
                    const cell = firstHeaderRow.getCell(colIndex++);
                    cell.value = fieldRenames[gc.id] || gc.name;
                    applyHeaderStyles(cell, 'rowGroups');
                    const existingColor = cell.font?.color;
                    cell.font = {
                        bold: true,
                        color: existingColor || { argb: `FF${headerFormatSettings.rowGroups?.fontColor || '000000'}` }
                    };
                    cell.alignment = { ...cell.alignment, wrapText: true };
                    applyBorder(cell);

                    if (totalHeaderRows > 1) {
                        ws.mergeCells(
                            currentRow,
                            colIndex - 1,
                            currentRow + totalHeaderRows - 1,
                            colIndex - 1
                        );
                    }
                });

                // PATCH: Calculate dynamic height for all header levels
                const actualColWidths = computeColWidths(config, pivotMap, rowKeys, colKeys);
                let maxHeaderLines = 1;

                // Check group headers
                groupCols.forEach((gc, idx) => {
                    const text = fieldRenames[gc.id] || gc.name;
                    const width = actualColWidths[idx] || 15;
                    const lines = calculateWrappedTextHeight(text, width);
                    maxHeaderLines = Math.max(maxHeaderLines, lines);
                });

                // Check pivot headers
                if (levels && levels.length > 0) {
                    levels.forEach(level => {
                        level.forEach(header => {
                            const avgWidth = 15;
                            const lines = calculateWrappedTextHeight(header.value, avgWidth);
                            maxHeaderLines = Math.max(maxHeaderLines, lines);
                        });
                    });
                }

                // Check value headers
                valueCols.forEach(vc => {
                    const text = fieldRenames[vc.id] || vc.name;
                    const lines = calculateWrappedTextHeight(text, 15);
                    maxHeaderLines = Math.max(maxHeaderLines, lines);
                });

                // Calculate dynamic header height
                const dynamicHeaderHeight = Math.max(22, Math.min(90, maxHeaderLines * 16 + 8));
                firstHeaderRow.height = dynamicHeaderHeight;

                // Pivot column hierarchy levels
                levels.forEach((level, levelIndex) => {
                    const row = levelIndex === 0 ? firstHeaderRow : ws.getRow(currentRow + levelIndex);
                    let currentCol = colIndex;

                    level.forEach(header => {
                        const cell = row.getCell(currentCol);
                        cell.value = header.value;
                        applyHeaderStyles(cell, 'columnGroups');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);

                        const span = header.span * valueCols.length;

                        if (span > 1) {
                            ws.mergeCells(
                                currentRow + levelIndex,
                                currentCol,
                                currentRow + levelIndex,
                                currentCol + span - 1
                            );
                        }

                        currentCol += span;
                    });

                    if (levelIndex > 0) {
                        row.height = dynamicHeaderHeight;
                    }
                });

                // Add metric group and value headers
                if (metricHeaders.hasGroups && metricHeaders.hasActualGroups) {
                    const metricGroupRow = ws.getRow(currentRow + depth);
                    let colIdx = colIndex;

                    colKeys.forEach(() => {
                        metricHeaders.groupHeaders.forEach(groupHeader => {
                            const cell = metricGroupRow.getCell(colIdx);
                            cell.value = groupHeader.name;
                            applyHeaderStyles(cell, 'columnGroups');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);

                            const span = groupHeader.isGroup ?
                                groupHeader.span / (colKeys.length || 1) : 1;

                            if (span > 1) {
                                ws.mergeCells(
                                    currentRow + depth,
                                    colIdx,
                                    currentRow + depth,
                                    colIdx + span - 1
                                );
                            }

                            colIdx += span;
                        });
                    });

                    if (showRowTotals) {
                        metricHeaders.groupHeaders.forEach(groupHeader => {
                            const cell = metricGroupRow.getCell(colIdx);
                            cell.value = groupHeader.name;
                            applyHeaderStyles(cell, 'totals');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);

                            const span = groupHeader.isGroup ?
                                groupHeader.span / (colKeys.length || 1) : 1;

                            if (span > 1) {
                                ws.mergeCells(
                                    currentRow + depth,
                                    colIdx,
                                    currentRow + depth,
                                    colIdx + span - 1
                                );
                            }

                            colIdx += span;
                        });

                        if (metricHeaders.ungroupedFields.length > 0) {
                            const cell = metricGroupRow.getCell(colIdx);
                            cell.value = 'Individual Metrics';
                            applyHeaderStyles(cell, 'totals');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);

                            if (metricHeaders.ungroupedFields.length > 1) {
                                ws.mergeCells(
                                    currentRow + depth,
                                    colIdx,
                                    currentRow + depth,
                                    colIdx + metricHeaders.ungroupedFields.length - 1
                                );
                            }
                        }
                    }

                    metricGroupRow.height = dynamicHeaderHeight;

                    // Individual metric headers row - PATCH: Fix this section
                    const valueRowIndex = currentRow + depth + 1;
                    const valueRow = ws.getRow(valueRowIndex);
                    let valueColIdx = colIndex;

                    colKeys.forEach(() => {
                        // PATCH: Use metricHeaders.subHeaders instead of valueCols directly
                        metricHeaders.subHeaders.forEach(subHeader => {
                            const cell = valueRow.getCell(valueColIdx++);
                            cell.value = subHeader.name;
                            applyHeaderStyles(cell, 'columnGroups');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);
                        });
                    });

                    if (showRowTotals) {
                        // PATCH: Use metricHeaders.subHeaders for row totals too
                        metricHeaders.subHeaders.forEach(subHeader => {
                            const cell = valueRow.getCell(valueColIdx++);
                            cell.value = subHeader.name;
                            applyHeaderStyles(cell, 'totals');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);
                        });
                    }

                    valueRow.height = dynamicHeaderHeight;

                } else if (valueCols.length > 1) {
                    const valueRowIndex = currentRow + depth;
                    const valueRow = ws.getRow(valueRowIndex);
                    let colIdx = colIndex;

                    colKeys.forEach(() => {
                        valueCols.forEach(vc => {
                            const cell = valueRow.getCell(colIdx++);
                            cell.value = fieldRenames[vc.id] || vc.name;
                            applyHeaderStyles(cell, 'columnGroups');
                            cell.font = { bold: true };
                            applyBorder(cell);
                        });
                    });

                    if (showRowTotals) {
                        valueCols.forEach(vc => {
                            const cell = valueRow.getCell(colIdx++);
                            cell.value = fieldRenames[vc.id] || vc.name;
                            applyHeaderStyles(cell, 'totals');
                            cell.font = { bold: true };
                            applyBorder(cell);
                        });
                    }
                }

                // Row totals main header
                if (showRowTotals) {
                    const rowTotalsColIndex = colIndex + totalPivotColumns;
                    const rowTotalsCell = firstHeaderRow.getCell(rowTotalsColIndex);
                    rowTotalsCell.value = config.rowTotalsLabel || 'Row Totals';
                    applyHeaderStyles(rowTotalsCell, 'totals');
                    const existingColor = rowTotalsCell.font?.color;
                    rowTotalsCell.font = {
                        bold: true,
                        color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                    };
                    rowTotalsCell.alignment = { ...rowTotalsCell.alignment, wrapText: true };
                    applyBorder(rowTotalsCell);

                    if (metricHeaders.hasGroups) {
                        if (depth > 1) {
                            ws.mergeCells(
                                currentRow,
                                rowTotalsColIndex,
                                currentRow + depth - 1,
                                rowTotalsColIndex + valueCols.length - 1
                            );
                        }
                    } else if (valueCols.length === 1) {
                        if (totalHeaderRows > 1) {
                            ws.mergeCells(
                                currentRow,
                                rowTotalsColIndex,
                                currentRow + totalHeaderRows - 1,
                                rowTotalsColIndex
                            );
                        }
                    } else {
                        ws.mergeCells(
                            currentRow,
                            rowTotalsColIndex,
                            currentRow + depth - 1,
                            rowTotalsColIndex + valueCols.length - 1
                        );
                    }
                }

                currentRow += totalHeaderRows;
            } else {
                // No pivot columns case - simplified for brevity but maintains all functionality
                let totalHeaderRows = 1;
                if (metricHeaders.hasGroups) {
                    totalHeaderRows = 2;
                }

                const headerRow = ws.getRow(currentRow);
                let colIndex = 1;

                groupCols.forEach(gc => {
                    const cell = headerRow.getCell(colIndex++);
                    cell.value = fieldRenames[gc.id] || gc.name;
                    applyHeaderStyles(cell, 'rowGroups');
                    const existingColor = cell.font?.color;
                    cell.font = {
                        bold: true,
                        color: existingColor || { argb: `FF${headerFormatSettings.rowGroups?.fontColor || '000000'}` }
                    };
                    cell.alignment = { ...cell.alignment, wrapText: true };
                    applyBorder(cell);

                    if (metricHeaders.hasGroups) {
                        ws.mergeCells(
                            currentRow,
                            colIndex - 1,
                            currentRow + 1,
                            colIndex - 1
                        );
                    }
                });

                headerRow.height = headerHeight;

                // Handle metric groups and value columns for no-pivot case
                if (metricHeaders.hasGroups && metricHeaders.hasActualGroups) {
                    // PATCH: Replace this entire section
                    // Add metric group headers
                    metricHeaders.groupHeaders.forEach(groupHeader => {
                        const cell = headerRow.getCell(colIndex);
                        cell.value = groupHeader.name;
                        applyHeaderStyles(cell, 'columnGroups');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);

                        const span = groupHeader.isGroup ?
                            groupHeader.span : 1;

                        if (span > 1) {
                            ws.mergeCells(
                                currentRow,
                                colIndex,
                                currentRow,
                                colIndex + span - 1
                            );
                        }

                        colIndex += span;
                    });

                    // Row totals header for metric groups
                    if (showRowTotals) {
                        metricHeaders.groupHeaders.forEach(groupHeader => {
                            const cell = headerRow.getCell(colIndex);
                            cell.value = groupHeader.name;
                            applyHeaderStyles(cell, 'totals');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);

                            const span = groupHeader.isGroup ?
                                groupHeader.span : 1;

                            if (span > 1) {
                                ws.mergeCells(
                                    currentRow,
                                    colIndex,
                                    currentRow,
                                    colIndex + span - 1
                                );
                            }

                            colIndex += span;
                        });
                    }

                    // Second row for individual metrics
                    const valueRowIndex = currentRow + 1;
                    const valueRow = ws.getRow(valueRowIndex);
                    let valueColIndex = groupCols.length + 1;

                    metricHeaders.subHeaders.forEach(subHeader => {
                        const cell = valueRow.getCell(valueColIndex++);
                        cell.value = subHeader.name;
                        applyHeaderStyles(cell, 'columnGroups');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);
                    });

                    if (showRowTotals) {
                        metricHeaders.subHeaders.forEach(subHeader => {
                            const cell = valueRow.getCell(valueColIndex++);
                            cell.value = subHeader.name;
                            applyHeaderStyles(cell, 'totals');
                            const existingColor = cell.font?.color;
                            cell.font = {
                                bold: true,
                                color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                            };
                            cell.alignment = { ...cell.alignment, wrapText: true };
                            applyBorder(cell);
                        });
                    }

                    valueRow.height = headerHeight;

                } else if (valueCols.length > 1) {
                    // Existing code for multiple value columns without groups...
                    valueCols.forEach(vc => {
                        const cell = headerRow.getCell(colIndex++);
                        cell.value = fieldRenames[vc.id] || vc.name;
                        applyHeaderStyles(cell, 'columnGroups');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);
                    });

                    if (showRowTotals) {
                        const cell = headerRow.getCell(colIndex);
                        cell.value = config.rowTotalsLabel || 'Row Totals';
                        applyHeaderStyles(cell, 'totals');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);

                        ws.mergeCells(
                            currentRow,
                            colIndex,
                            currentRow,
                            colIndex + valueCols.length - 1
                        );
                    }
                } else {
                    // Single value column case...
                    valueCols.forEach(vc => {
                        const cell = headerRow.getCell(colIndex++);
                        cell.value = fieldRenames[vc.id] || vc.name;
                        applyHeaderStyles(cell, 'columnGroups');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.columnGroups?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);
                    });

                    if (showRowTotals) {
                        const cell = headerRow.getCell(colIndex);
                        cell.value = config.rowTotalsLabel || 'Row Totals';
                        applyHeaderStyles(cell, 'totals');
                        const existingColor = cell.font?.color;
                        cell.font = {
                            bold: true,
                            color: existingColor || { argb: `FF${headerFormatSettings.totals?.fontColor || '000000'}` }
                        };
                        cell.alignment = { ...cell.alignment, wrapText: true };
                        applyBorder(cell);
                    }
                }

                currentRow += totalHeaderRows;
            }

            // OPTIMIZED: Data rows with batch processing
            updateProgress('Processing data rows...', 25);
            let prevGroup = null;
            const batchSize = 50; // Smaller batches for large datasets

            for (let batchStart = 0; batchStart < rowKeys.length; batchStart += batchSize) {
                const batchEnd = Math.min(batchStart + batchSize, rowKeys.length);
                const batchKeys = rowKeys.slice(batchStart, batchEnd);

                for (const rk of batchKeys) {
                    const rowVals = rk.split('|');
                    const bgColor = rowColorMap.get(rk) || null;

                    // Insert subtotals (simplified for performance)
                    if (showSubtotals && prevGroup !== null) {
                        for (let lvl = groupCols.length - 1; lvl >= 0; lvl--) {
                            if (prevGroup[lvl] !== rowVals[lvl] && selectedSubtotalLevels.includes(lvl)) {
                                const subtotalRow = ws.getRow(currentRow);
                                let colIdx = 1;

                                // Group columns
                                groupCols.forEach((gc, idx) => {
                                    const cell = subtotalRow.getCell(colIdx++);
                                    if (idx === lvl) {
                                        // PATCH: Show only custom label or group value + "Subtotal"
                                        if (config.useCustomSubtotalLabels && config.subtotalLabels && config.subtotalLabels[lvl]) {
                                            cell.value = config.subtotalLabels[lvl];
                                        } else {
                                            let groupVal = cleanDisplayValue(prevGroup[lvl]);

                                            // Apply date formatting if configured
                                            const settings = formatSettings[gc.id];
                                            if (settings?.formatType === 'date' && !isNullValue(prevGroup[lvl])) {
                                                try {
                                                    const dateVal = new Date(prevGroup[lvl]);
                                                    if (!isNaN(dateVal.getTime())) {
                                                        const formatStr = settings.dateFormat || 'MM/DD/YYYY';
                                                        const day = dateVal.getDate().toString().padStart(2, '0');
                                                        const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                                        const year = dateVal.getFullYear().toString();
                                                        groupVal = formatStr
                                                            .replace('YYYY', year)
                                                            .replace('MM', month)
                                                            .replace('DD', day);
                                                    }
                                                } catch (e) {}
                                            }

                                            cell.value = `${groupVal} Subtotal`;
                                        }
                                    } else if (idx < lvl) {
                                        // Clean the display value and apply date formatting
                                        let cleanVal = cleanDisplayValue(prevGroup[idx]);

                                        const settings = formatSettings[gc.id];
                                        if (settings?.formatType === 'date' && !isNullValue(prevGroup[idx])) {
                                            try {
                                                const dateVal = new Date(prevGroup[idx]);
                                                if (!isNaN(dateVal.getTime())) {
                                                    const formatStr = settings.dateFormat || 'MM/DD/YYYY';
                                                    const day = dateVal.getDate().toString().padStart(2, '0');
                                                    const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                                    const year = dateVal.getFullYear().toString();
                                                    cleanVal = formatStr
                                                        .replace('YYYY', year)
                                                        .replace('MM', month)
                                                        .replace('DD', day);
                                                }
                                            } catch (e) {}
                                        }

                                        cell.value = cleanVal;
                                    } else {
                                        cell.value = '';
                                    }
                                    applyHeaderStyles(cell, 'subtotals');
                                    cell.font = { bold: true };
                                    applyBorder(cell);
                                });

                                // Batch calculate subtotals with proper null handling
                                const subtotals = new Map();
                                valueCols.forEach(v => {
                                    colKeys.forEach(ck => {
                                        let sum = null;
                                        for (const [key, dataObj] of pivotMap) {
                                            const [rPart, cPart] = key.split('>>>');
                                            if (cPart === ck && rPart.split('|')[lvl] === prevGroup[lvl]) {
                                                sum = aggregateValues(sum, dataObj[v.id]);
                                            }
                                        }
                                        subtotals.set(`${ck}_${v.id}`, sum);
                                    });
                                });

                                // Apply subtotals
                                colKeys.forEach(ck => {
                                    valueCols.forEach(v => {
                                        const cell = subtotalRow.getCell(colIdx++);
                                        const sum = subtotals.get(`${ck}_${v.id}`);

                                        // Handle null subtotals properly
                                        if (sum === null || sum === undefined) {
                                            cell.value = null; // Excel will show this as blank
                                        } else {
                                            // PATCH: Apply formatting logic for subtotals
                                            const settings = formatSettings[v.id] || {};
                                            const formatType = settings.formatType || 'number';

                                            if (formatType === 'text') {
                                                cell.value = sum.toString();
                                            } else if (settings.decimals !== null && settings.decimals !== undefined) {
                                                // Format is specified - keep as number for Excel
                                                cell.value = typeof sum === 'number' ? sum : parseFloat(sum);
                                            } else {
                                                // No specific formatting - preserve precision
                                                cell.value = typeof sum === 'number' ? sum : parseFloat(sum);
                                            }
                                        }

                                        cell.numFmt = getNumberFormat(v.id);
                                        applyHeaderStyles(cell, 'subtotals');
                                        cell.font = { bold: true };
                                        applyBorder(cell);
                                    });
                                });

                                if (showRowTotals) {
                                    valueCols.forEach(v => {
                                        const cell = subtotalRow.getCell(colIdx++);
                                        let rowSum = null;
                                        for (const [key, dataObj] of pivotMap) {
                                            const [rPart] = key.split('>>>');
                                            if (rPart.split('|')[lvl] === prevGroup[lvl]) {
                                                rowSum = aggregateValues(rowSum, dataObj[v.id]);
                                            }
                                        }

                                        // Handle null row sums properly
                                        if (rowSum === null || rowSum === undefined) {
                                            cell.value = null; // Excel will show this as blank
                                        } else {
                                            cell.value = rowSum;
                                        }

                                        cell.numFmt = getNumberFormat(v.id);
                                        applyHeaderStyles(cell, 'subtotals');
                                        cell.font = { bold: true };
                                        applyBorder(cell);
                                    });
                                }

                                currentRow++;
                            }
                        }
                    }

                    // Data row
                    const dataRow = ws.getRow(currentRow);
                    let colIdx = 1;

                    // Group columns - clean null values and apply date formatting
                    rowVals.forEach((val, idx) => {
                        const cell = dataRow.getCell(colIdx++);
                        // Clean the display value - show blank for nulls
                        let cleanVal = cleanDisplayValue(val);

                        // Apply date formatting if this column is configured as a date
                        const settings = formatSettings[groupCols[idx].id];
                        if (settings?.formatType === 'date' && !isNullValue(val)) {
                            try {
                                const dateVal = new Date(val);
                                if (!isNaN(dateVal.getTime())) {
                                    const formatStr = settings.dateFormat || 'MM/DD/YYYY';
                                    const day = dateVal.getDate().toString().padStart(2, '0');
                                    const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                    const year = dateVal.getFullYear().toString();

                                    // Basic replacement - can be expanded for more tokens
                                    cleanVal = formatStr
                                        .replace('YYYY', year)
                                        .replace('MM', month)
                                        .replace('DD', day);
                                }
                            } catch (e) {
                                // If date parsing fails, keep the original cleaned value
                            }
                        }

                        cell.value = cleanVal;
                        cell.alignment = { vertical: 'middle', horizontal: 'left' };
                        cell.numFmt = '@';

                        // Apply conditional formatting efficiently
                        if (settings?.conditions) {
                            for (const cond of settings.conditions) {
                                let met = false;
                                // Use original val for comparison, but only if it's not null
                                const comparisonVal = isNullValue(val) ? '' : val;
                                if (cond.operator === '==' && comparisonVal === cond.value?.toString()) {
                                    met = true;
                                } else if (['>', '<'].includes(cond.operator) && !isNullValue(val)) {
                                    const nv = parseFloat(val), cv = parseFloat(cond.value);
                                    if (!isNaN(nv) && !isNaN(cv)) {
                                        met = cond.operator === '>' ? (nv > cv) : (nv < cv);
                                    }
                                }
                                if (met) {
                                    if (cond.fontColor) {
                                        cell.font = cell.font || {};
                                        cell.font.color = { argb: `FF${cond.fontColor}` };
                                    }
                                    break;
                                }
                            }
                        }

                        if (bgColor) {
                            cell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: `FF${bgColor}` }
                            };
                        }
                        applyBorder(cell);
                    });

                    // Process data values efficiently
                    const rowTotal = {};
                    valueCols.forEach(v => rowTotal[v.id] = null); // Initialize with null

                    colKeys.forEach(ck => {
                        const mapKey = `${rk}>>>${ck}`;
                        const dataObj = pivotMap.get(mapKey);

                        valueCols.forEach(v => {
                            const rawVal = dataObj ? dataObj[v.id] : null; // Get actual value (could be null)
                            const cell = dataRow.getCell(colIdx++);

                            // Handle null values properly in Excel
                            if (rawVal === null || rawVal === undefined) {
                                cell.value = null; // Excel will show this as blank
                            } else {
                                // PATCH: Always store as number if possible, let Excel format handle display
                                if (typeof rawVal === 'number') {
                                    cell.value = rawVal; // Use the number directly to preserve precision
                                } else {
                                    const numVal = parseFloat(rawVal);
                                    cell.value = isNaN(numVal) ? rawVal : numVal;
                                }
                            }

                            // Apply Excel number format (this controls display based on your settings)
                            cell.numFmt = getNumberFormat(v.id);
                            cell.alignment = { vertical: 'middle', horizontal: 'right' };

                            // Apply value formatting efficiently
                            const valueFormatting = evaluateValueConditions(rawVal, v.id);

                            if (valueFormatting.fontColor) {
                                cell.font = cell.font || {};
                                cell.font.color = { argb: `FF${valueFormatting.fontColor}` };
                            }

                            if (valueFormatting.bgColor && !bgColor) {
                                cell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: `FF${valueFormatting.bgColor}` }
                                };
                            } else if (bgColor) {
                                cell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: `FF${bgColor}` }
                                };
                            }

                            applyBorder(cell);

                            // Aggregate row totals properly
                            rowTotal[v.id] = aggregateValues(rowTotal[v.id], rawVal);
                        });
                    });

                    // Row totals
                    if (showRowTotals) {
                        valueCols.forEach(v => {
                            const cell = dataRow.getCell(colIdx++);
                            const totalVal = rowTotal[v.id];

                            // Handle null totals properly
                            if (totalVal === null || totalVal === undefined) {
                                cell.value = null; // Excel will show this as blank
                            } else {
                                // PATCH: Apply formatting logic for row totals
                                const settings = formatSettings[v.id] || {};
                                const formatType = settings.formatType || 'number';

                                if (formatType === 'text') {
                                    cell.value = totalVal.toString();
                                } else if (settings.decimals !== null && settings.decimals !== undefined) {
                                    // Format is specified - keep as number for Excel
                                    cell.value = typeof totalVal === 'number' ? totalVal : parseFloat(totalVal);
                                } else {
                                    // No specific formatting - preserve precision
                                    cell.value = typeof totalVal === 'number' ? totalVal : parseFloat(totalVal);
                                }
                            }

                            cell.numFmt = getNumberFormat(v.id);
                            cell.font = { bold: true };
                            cell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: 'FFEFEFEF' }
                            };

                            const valueFormatting = evaluateValueConditions(totalVal, v.id);
                            if (valueFormatting.fontColor) {
                                cell.font = cell.font || {};
                                cell.font.color = { argb: `FF${valueFormatting.fontColor}` };
                                cell.font.bold = true;
                            }

                            applyBorder(cell);
                        });
                    }

                    currentRow++;
                    prevGroup = rowVals;
                    dataRow.height = 25;
                }

                // Update progress
                const progress = 25 + ((batchEnd / rowKeys.length) * 50);
                updateProgress(`Processing rows: ${Math.round((batchEnd / rowKeys.length) * 100)}%`, progress);
                await sleep(1); // Allow UI to update
            }

            // PATCH: Insert final subtotals after processing all data rows
            if (showSubtotals && prevGroup !== null) {
                for (let lvl = groupCols.length - 1; lvl >= 0; lvl--) {
                    if (selectedSubtotalLevels.includes(lvl)) {
                        const subtotalRow = ws.getRow(currentRow);
                        let colIdx = 1;

                        // Group columns
                        groupCols.forEach((gc, idx) => {
                            const cell = subtotalRow.getCell(colIdx++);
                            if (idx === lvl) {
                                // PATCH: Show only custom label or group value + "Subtotal"
                                if (config.useCustomSubtotalLabels && config.subtotalLabels && config.subtotalLabels[lvl]) {
                                    cell.value = config.subtotalLabels[lvl];
                                } else {
                                    let groupVal = cleanDisplayValue(prevGroup[lvl]);

                                    // Apply date formatting if configured
                                    const settings = formatSettings[gc.id];
                                    if (settings?.formatType === 'date' && !isNullValue(prevGroup[lvl])) {
                                        try {
                                            const dateVal = new Date(prevGroup[lvl]);
                                            if (!isNaN(dateVal.getTime())) {
                                                const formatStr = settings.dateFormat || 'MM/DD/YYYY';
                                                const day = dateVal.getDate().toString().padStart(2, '0');
                                                const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                                const year = dateVal.getFullYear().toString();
                                                groupVal = formatStr
                                                    .replace('YYYY', year)
                                                    .replace('MM', month)
                                                    .replace('DD', day);
                                            }
                                        } catch (e) {}
                                    }

                                    cell.value = `${groupVal} Subtotal`;
                                }
                            } else if (idx < lvl) {
                                let cleanVal = cleanDisplayValue(prevGroup[idx]);

                                const settings = formatSettings[gc.id];
                                if (settings?.formatType === 'date' && !isNullValue(prevGroup[idx])) {
                                    try {
                                        const dateVal = new Date(prevGroup[idx]);
                                        if (!isNaN(dateVal.getTime())) {
                                            const formatStr = settings.dateFormat || 'MM/DD/YYYY';
                                            const day = dateVal.getDate().toString().padStart(2, '0');
                                            const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                            const year = dateVal.getFullYear().toString();
                                            cleanVal = formatStr
                                                .replace('YYYY', year)
                                                .replace('MM', month)
                                                .replace('DD', day);
                                        }
                                    } catch (e) {}
                                }

                                cell.value = cleanVal;
                            } else {
                                cell.value = '';
                            }
                            applyHeaderStyles(cell, 'subtotals');
                            cell.font = { bold: true };
                            applyBorder(cell);
                        });

                        // Batch calculate subtotals with proper null handling
                        const subtotals = new Map();
                        valueCols.forEach(v => {
                            colKeys.forEach(ck => {
                                let sum = null;
                                for (const [key, dataObj] of pivotMap) {
                                    const [rPart, cPart] = key.split('>>>');
                                    if (cPart === ck && rPart.split('|')[lvl] === prevGroup[lvl]) {
                                        sum = aggregateValues(sum, dataObj[v.id]);
                                    }
                                }
                                subtotals.set(`${ck}_${v.id}`, sum);
                            });
                        });

                        // Apply subtotals
                        colKeys.forEach(ck => {
                            valueCols.forEach(v => {
                                const cell = subtotalRow.getCell(colIdx++);
                                const sum = subtotals.get(`${ck}_${v.id}`);

                                // Handle null subtotals properly
                                if (sum === null || sum === undefined) {
                                    cell.value = null; // Excel will show this as blank
                                } else {
                                    // Apply formatting logic for subtotals
                                    const settings = formatSettings[v.id] || {};
                                    const formatType = settings.formatType || 'number';

                                    if (formatType === 'text') {
                                        cell.value = sum.toString();
                                    } else if (settings.decimals !== null && settings.decimals !== undefined) {
                                        // Format is specified - keep as number for Excel
                                        cell.value = typeof sum === 'number' ? sum : parseFloat(sum);
                                    } else {
                                        // No specific formatting - preserve precision
                                        cell.value = typeof sum === 'number' ? sum : parseFloat(sum);
                                    }
                                }

                                cell.numFmt = getNumberFormat(v.id);
                                applyHeaderStyles(cell, 'subtotals');
                                cell.font = { bold: true };
                                applyBorder(cell);
                            });
                        });

                        if (showRowTotals) {
                            valueCols.forEach(v => {
                                const cell = subtotalRow.getCell(colIdx++);
                                let rowSum = null;
                                for (const [key, dataObj] of pivotMap) {
                                    const [rPart] = key.split('>>>');
                                    if (rPart.split('|')[lvl] === prevGroup[lvl]) {
                                        rowSum = aggregateValues(rowSum, dataObj[v.id]);
                                    }
                                }

                                // Handle null row sums properly
                                if (rowSum === null || rowSum === undefined) {
                                    cell.value = null; // Excel will show this as blank
                                } else {
                                    cell.value = rowSum;
                                }

                                cell.numFmt = getNumberFormat(v.id);
                                applyHeaderStyles(cell, 'subtotals');
                                cell.font = { bold: true };
                                applyBorder(cell);
                            });
                        }

                        currentRow++;
                    }
                }
            }

            // Column totals (optimized calculation)
            if (showColumnTotals) {
                updateProgress('Calculating totals...', 85);

                const footerRow = ws.getRow(currentRow);
                let colIdx = 1;

                groupCols.forEach((gc, idx) => {
                    const cell = footerRow.getCell(colIdx++);
                    cell.value = (idx === 0) ? (config.columnTotalsLabel || 'Grand Total') : '';
                    applyHeaderStyles(cell, 'rowGroups');
                    cell.font = { bold: true };
                    applyBorder(cell);
                });

                // Batch calculate column totals with proper null handling
                const columnTotals = new Map();
                colKeys.forEach(ck => {
                    valueCols.forEach(v => {
                        let colSum = null;
                        for (const [key, dataObj] of pivotMap) {
                            const [, cPart] = key.split('>>>');
                            if (cPart === ck) {
                                colSum = aggregateValues(colSum, dataObj[v.id]);
                            }
                        }
                        columnTotals.set(`${ck}_${v.id}`, colSum);
                    });
                });

                colKeys.forEach(ck => {
                    valueCols.forEach(v => {
                        const colSum = columnTotals.get(`${ck}_${v.id}`);
                        const cell = footerRow.getCell(colIdx++);

                        // Handle null column totals properly
                        if (colSum === null || colSum === undefined) {
                            cell.value = null; // Excel will show this as blank
                        } else {
                            // PATCH: Apply formatting logic for column totals
                            const settings = formatSettings[v.id] || {};
                            const formatType = settings.formatType || 'number';

                            if (formatType === 'text') {
                                cell.value = colSum.toString();
                            } else if (settings.decimals !== null && settings.decimals !== undefined) {
                                // Format is specified - keep as number for Excel
                                cell.value = typeof colSum === 'number' ? colSum : parseFloat(colSum);
                            } else {
                                // No specific formatting - preserve precision
                                cell.value = typeof colSum === 'number' ? colSum : parseFloat(colSum);
                            }
                        }

                        cell.numFmt = getNumberFormat(v.id);
                        applyHeaderStyles(cell, 'totals');
                        cell.font = { bold: true };
                        cell.fill = {
                            type: 'pattern',
                            pattern: 'solid',
                            fgColor: { argb: `FFEFEFEF` }
                        };

                        const valueFormatting = evaluateValueConditions(colSum, v.id);
                        if (valueFormatting.fontColor) {
                            cell.font = cell.font || {};
                            cell.font.color = { argb: `FF${valueFormatting.fontColor}` };
                            cell.font.bold = true;
                        }

                        applyBorder(cell);
                    });
                });

                // Grand total
                if (showRowTotals) {
                    valueCols.forEach(v => {
                        let grandTotal = null;
                        for (const [, dataObj] of pivotMap) {
                            grandTotal = aggregateValues(grandTotal, dataObj[v.id]);
                        }

                        const cell = footerRow.getCell(colIdx++);

                        // Handle null grand totals properly
                        if (grandTotal === null || grandTotal === undefined) {
                            cell.value = null; // Excel will show this as blank
                        } else {
                            // PATCH: Apply formatting logic for grand totals
                            const settings = formatSettings[v.id] || {};
                            const formatType = settings.formatType || 'number';

                            if (formatType === 'text') {
                                cell.value = grandTotal.toString();
                            } else if (settings.decimals !== null && settings.decimals !== undefined) {
                                // Format is specified - keep as number for Excel
                                cell.value = typeof grandTotal === 'number' ? grandTotal : parseFloat(grandTotal);
                            } else {
                                // No specific formatting - preserve precision
                                cell.value = typeof grandTotal === 'number' ? grandTotal : parseFloat(grandTotal);
                            }
                        }

                        cell.numFmt = getNumberFormat(v.id);
                        applyHeaderStyles(cell, 'totals');
                        cell.font = { bold: true };

                        const valueFormatting = evaluateValueConditions(grandTotal, v.id);
                        if (valueFormatting.fontColor) {
                            cell.font = cell.font || {};
                            cell.font.color = { argb: `FF${valueFormatting.fontColor}` };
                            cell.font.bold = true;
                        }

                        if (valueFormatting.bgColor) {
                            cell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: `FF${valueFormatting.bgColor}` }
                            };
                        }
                        applyBorder(cell);
                    });
                }
            }

            updateProgress('Excel sheet complete', 95);
        }

        async function buildDataDumpSheet(ws, config, dataDumpResult) {
            updateProgress('Building data dump sheet...', 0);

            const { data, columns: dataDumpColumns } = dataDumpResult;

            // Set column widths - simple auto-sizing
            ws.columns = dataDumpColumns.map((col, idx) => ({
                width: Math.max(15, col.displayName.length + 5),
                key: idx + 1
            }));

            let currentRow = 1;

            // Helper functions
            function applyBorder(cell) {
                cell.border = {
                    top: { style: 'thin', color: { argb: 'FF808080' } },
                    left: { style: 'thin', color: { argb: 'FF808080' } },
                    bottom: { style: 'thin', color: { argb: 'FF808080' } },
                    right: { style: 'thin', color: { argb: 'FF808080' } }
                };
            }

            // Custom header rows processing (reuse from pivot logic)
            updateProgress('Adding custom headers...', 10);
            for (let i = 0; i < headerRowsCount; i++) {
                const s = headerRowSettings[i] || {
                    type: 'text',
                    text: `Header Row ${i + 1}`,
                    column: '',
                    fontColor: '000000',
                    bgColor: 'F8F9FA',
                    textAlign: 'left'
                };

                let text = '';

                if (s.type === 'text') {
                    text = s.text;
                } else if (s.type === 'column') {
                    text = titleColumnMap[s.column] || '';
                } else if (s.type === 'filters') {
                    const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                        .find(w => w.name === currentWorksheetName);
                    if (worksheet) {
                        const filters = await worksheet.getFiltersAsync();
                        const displayFilters = s.selectedFilters && s.selectedFilters.length > 0
                            ? filters.filter(f => s.selectedFilters.includes(f.fieldName))
                            : filters;

                        const lines = [];
                        for (const f of displayFilters) {
                            if (f.filterType === 'categorical') {
                                const fn = f.fieldName;
                                const av = f.appliedValues;
                                const valText = av.length === 0 ? 'All' : av.map(x => isNullValue(x.value) ? 'Null' : cleanDisplayValue(x.value)).join(', ');
                                lines.push(`${fn}: ${valText}`);
                            }
                        }
                        text = lines.join('\n');
                    } else {
                        text = 'Worksheet not found';
                    }
                } else if (s.type === 'refreshDate') {
                    // FIXED: Process actual refresh date with custom formatting
                    const worksheet = tableau.extensions.dashboardContent.dashboard.worksheets
                        .find(w => w.name === currentWorksheetName);
                    if (worksheet) {
                        try {
                            const dataSources = await worksheet.getDataSourcesAsync();
                            const ds = dataSources[0];
                            const extractTime = ds ? ds.extractUpdateTime : undefined;

                            if (extractTime) {
                                try {
                                    const tzInput = s.timeZone || 'UTC';
                                    let formatOpts = s.dateFormat
                                        ? JSON.parse(s.dateFormat)
                                        : {
                                            year: 'numeric',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        };
                                    text = formatDateWithCustomSeparator(new Date(extractTime), formatOpts, tzInput);
                                    if (s.prefixText) {
                                        text = s.prefixText + ' ' + text;
                                    }
                                } catch (e) {
                                    text = new Date(extractTime).toUTCString();
                                }
                            } else {
                                text = 'â€”';
                            }
                        } catch (error) {
                            console.error('Error fetching refresh date for CSV:', error);
                            text = 'Data refresh time: [Error loading]';
                        }
                    } else {
                        text = 'Data refresh time: [Worksheet not found]';
                    }
                }

                const row = ws.getRow(currentRow);
                const cell = row.getCell(1);
                cell.value = text;
                cell.alignment = {
                    vertical: 'middle',
                    horizontal: s.textAlign,
                    wrapText: true
                };
                cell.font = {
                    color: { argb: `FF${s.fontColor}` },
                    bold: true
                };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: `FF${s.bgColor}` }
                };
                applyBorder(cell);

                ws.mergeCells(currentRow, 1, currentRow, dataDumpColumns.length);
                // PATCH: Dynamic height for data dump headers
                const textLines = calculateWrappedTextHeight(text, 50);
                row.height = Math.max(20, Math.min(80, textLines * 16 + 6));
                currentRow++;
            }

            // Table title
            if (tableTitle) {
                updateProgress('Adding table title...', 20);
                const row = ws.getRow(currentRow);
                const cell = row.getCell(1);
                cell.value = tableTitle;
                cell.font = {
                    bold: true,
                    color: { argb: `FF${titleFontColor}` }
                };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: `FF${titleBgColor}` }
                };
                cell.alignment = {
                    vertical: 'middle',
                    horizontal: titleAlignment,
                    wrapText: true
                };
                applyBorder(cell);

                ws.mergeCells(currentRow, 1, currentRow, dataDumpColumns.length);
                // PATCH: Dynamic height for data dump title
                const titleLines = calculateWrappedTextHeight(tableTitle, 50);
                row.height = Math.max(22, Math.min(90, titleLines * 18 + 8));
                currentRow++;
            }

            // Column headers
            updateProgress('Adding column headers...', 30);
            const headerRow = ws.getRow(currentRow);
            dataDumpColumns.forEach((col, index) => {
                const cell = headerRow.getCell(index + 1);
                cell.value = col.displayName;
                cell.font = {
                    bold: true,
                    color: { argb: 'FF000000' }
                };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFF1F3F5' }
                };
                cell.alignment = {
                    vertical: 'middle',
                    horizontal: 'left',
                    wrapText: true
                };
                applyBorder(cell);
            });

            // PATCH: Calculate dynamic height for column headers
            let maxHeaderLines = 1;
            dataDumpColumns.forEach(col => {
                const lines = calculateWrappedTextHeight(col.displayName, 20);
                maxHeaderLines = Math.max(maxHeaderLines, lines);
            });

            headerRow.height = Math.max(20, Math.min(70, maxHeaderLines * 16 + 6));
            currentRow++;

            // Data rows with batch processing
            updateProgress('Adding data rows...', 40);
            const batchSize = 1000;
            for (let i = 0; i < data.length; i += batchSize) {
                const batch = data.slice(i, i + batchSize);

                batch.forEach(row => {
                    const dataRow = ws.getRow(currentRow);

                    dataDumpColumns.forEach((col, colIndex) => {
                        const cell = dataRow.getCell(colIndex + 1);
                        const value = row[col.displayName];

                        // Clean display value - show blank for nulls
                        let cleanValue = cleanDisplayValue(value);

                        // Apply date formatting if this column is configured as a date
                        if (col.formatType === 'date' && !isNullValue(value)) {
                            try {
                                const dateVal = new Date(value);
                                if (!isNaN(dateVal.getTime())) {
                                    const formatStr = col.dateFormat || 'MM/DD/YYYY';
                                    const day = dateVal.getDate().toString().padStart(2, '0');
                                    const month = (dateVal.getMonth() + 1).toString().padStart(2, '0');
                                    const year = dateVal.getFullYear().toString();

                                    cleanValue = formatStr
                                        .replace('YYYY', year)
                                        .replace('MM', month)
                                        .replace('DD', day);
                                }
                            } catch (e) {
                                // If date parsing fails, keep the original cleaned value
                            }
                        }

                        cell.value = cleanValue;

                        // Basic formatting
                        cell.alignment = {
                            vertical: 'middle',
                            horizontal: 'left'
                        };

                        // Auto-detect number format for better Excel compatibility
                        if (col.formatType !== 'date' && cleanValue && !isNullValue(cleanValue) && !isNaN(cleanValue) && cleanValue.toString().trim() !== '') {
                            const numValue = parseFloat(cleanValue);
                            if (!isNaN(numValue)) {
                                cell.value = numValue;
                                if (Number.isInteger(numValue)) {
                                    cell.numFmt = '0';
                                } else {
                                    cell.numFmt = '0.00';
                                }
                            }
                        } else {
                            cell.numFmt = '@'; // Text format
                        }

                        applyBorder(cell);
                    });

                    dataRow.height = 20;
                    currentRow++;
                });

                // Update progress and yield control
                const progress = 40 + ((batchEnd / data.length) * 50);
                updateProgress(`Processing rows: ${Math.round((batchEnd / data.length) * 100)}%`, progress);
                await sleep(1);
            }

            updateProgress('Data dump sheet complete', 95);
        }

        function isNullValue(value) {
            if (value === null || value === undefined) return true;

            const strValue = String(value).toLowerCase().trim();
            return strValue === '' ||
                strValue === 'null' ||
                strValue === 'Null' ||
                strValue === 'NULL' ||
                strValue === 'nulls' ||
                strValue === '%null%' ||
                strValue === '(null)' ||
                strValue === 'n/a' ||
                strValue === 'na';
        }

        // Function to clean and display null values
        function cleanDisplayValue(value) {
            return isNullValue(value) ? '' : String(value);
        }


        async function refreshWorksheetDataForExport(worksheetName) {
            let dataTableReader = null;
            try {
                updateProgress('Connecting to worksheet...', 0);

                const ws = tableau.extensions.dashboardContent.dashboard.worksheets
                    .find(w => w.name === worksheetName);
                if (!ws) {
                    console.error(`Worksheet "${worksheetName}" not found`);
                    throw new Error(`Worksheet "${worksheetName}" not found`);
                }

                updateProgress('Reading column information...', 5);
                const colsInfo = await ws.getSummaryColumnsInfoAsync();

                // Check if worksheet has columns
                if (!colsInfo || colsInfo.length === 0) {
                    console.warn(`Worksheet "${worksheetName}" has no columns`);
                    columns = [];
                    allData = [];
                    titleColumnMap = {};
                    updateProgress('No data available', 100);
                    return;
                }

                dataTableReader = await ws.getSummaryDataReaderAsync();

                // Check if there are pages to read
                if (dataTableReader.pageCount === 0) {
                    console.warn(`Worksheet "${worksheetName}" has no data pages`);
                    columns = colsInfo.map(c => ({ id: c.fieldName, name: c.fieldName }));
                    allData = [];
                    titleColumnMap = {};
                    updateProgress('No data to process', 100);
                    return;
                }

                const firstPage = await dataTableReader.getPageAsync(0);
                const sortedCols = firstPage.columns;
                const indexMap = colsInfo.map(vc =>
                    sortedCols.findIndex(sc => sc.fieldId === vc.fieldId)
                );

                columns = colsInfo.map(c => ({ id: c.fieldName, name: c.fieldName }));
                allData = [];

                updateProgress('Loading data pages...', 10);

                // Process pages in batches for better memory management
                for (let p = 0; p < dataTableReader.pageCount; p++) {
                    try {
                        const pageData = await dataTableReader.getPageAsync(p);
                        const pageRows = [];

                        if (!pageData.data || pageData.totalRowCount === 0) {
                            continue;
                        }

                        for (let r = 0; r < pageData.totalRowCount; r++) {
                            try {
                                const row = pageData.data[r];
                                if (!row) continue;

                                const obj = {};
                                colsInfo.forEach((c, ci) => {
                                    const srcIdx = indexMap[ci];
                                    if (srcIdx >= 0 && srcIdx < row.length) {
                                        // PATCH: Intelligently choose between nativeValue and formattedValue
                                        const cell = row[srcIdx];
                                        let rawValue;

                                        if (cell?.nativeValue !== undefined && cell?.nativeValue !== null) {
                                            const nativeValue = cell.nativeValue;
                                            const formattedValue = cell.formattedValue;

                                            // PATCH: Always prefer formattedValue for dates to preserve Tableau's display format
                                            if (nativeValue instanceof Date) {
                                                // For Date objects, always use the formatted value to preserve the original display
                                                rawValue = formattedValue || nativeValue.toLocaleDateString();
                                            } else if (typeof nativeValue === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(nativeValue)) {
                                                // ISO date strings - use formatted value
                                                rawValue = formattedValue || nativeValue.split('T')[0];
                                            } else if (formattedValue && typeof formattedValue === 'string') {
                                                // Check if formatted value looks like a date
                                                const isFormattedDate = /\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}|\d{4}[-\/]\d{1,2}[-\/]\d{1,2}/.test(formattedValue);

                                                if (isFormattedDate) {
                                                    // Use formatted value for dates
                                                    rawValue = formattedValue;
                                                } else {
                                                    // Regular logic for non-dates
                                                    const formattedStr = formattedValue.toString();
                                                    const hasTextContent = /[a-zA-Z]/.test(formattedStr);
                                                    const hasComplexFormatting = /[^0-9.,\-+$%\s]/.test(formattedStr);

                                                    if (hasTextContent || hasComplexFormatting) {
                                                        rawValue = formattedValue;
                                                    } else {
                                                        rawValue = nativeValue;
                                                    }
                                                }
                                            } else {
                                                // Numeric values - use native for precision
                                                rawValue = nativeValue;
                                            }
                                        } else if (cell?.formattedValue !== undefined && cell?.formattedValue !== null) {
                                            rawValue = cell.formattedValue;
                                        } else {
                                            rawValue = null;
                                        }

                                        // Clean null values immediately
                                        obj[c.fieldName] = isNullValue(rawValue) ? null : rawValue;
                                        obj[c.fieldName + '_formatted'] = cell?.formattedValue || '';
                                    } else {
                                        obj[c.fieldName] = null;
                                    }
                                });
                                pageRows.push(obj);
                            } catch (rowError) {
                                console.warn(`Error processing row ${r} on page ${p}:`, rowError);
                                continue;
                            }
                        }

                        allData.push(...pageRows);

                        // Update progress and yield control
                        const progress = 10 + ((p + 1) / dataTableReader.pageCount) * 60;
                        updateProgress(`Loading data: ${Math.round(((p + 1) / dataTableReader.pageCount) * 100)}% (${allData.length} rows)`, progress);

                        if (p % 10 === 0) { // Yield every 10 pages
                            await sleep(1);
                        }
                    } catch (pageError) {
                        console.warn(`Error processing page ${p}:`, pageError);
                        continue;
                    }
                }

                updateProgress('Cleaning data...', 75);

                // Clean up null values in batches
                const cleanBatchSize = 1000;
                for (let i = 0; i < allData.length; i += cleanBatchSize) {
                    const endIdx = Math.min(i + cleanBatchSize, allData.length);

                    for (let j = i; j < endIdx; j++) {
                        const row = allData[j];
                        columns.forEach(c => {
                            if (isNullValue(row[c.id])) {
                                row[c.id] = null;
                            }
                        });
                    }

                    // Yield control periodically
                    if (i % (cleanBatchSize * 5) === 0) {
                        const progress = 75 + ((i / allData.length) * 20);
                        updateProgress(`Cleaning data: ${Math.round((i / allData.length) * 100)}%`, progress);
                        await sleep(1);
                    }
                }

                // Build title column map efficiently
                updateProgress('Building metadata...', 95);
                titleColumnMap = {};
                for (let i = 0; i < Math.min(100, allData.length); i++) { // Sample first 100 rows
                    const row = allData[i];
                    columns.forEach(c => {
                        if (!titleColumnMap[c.id] && row[c.id]) {
                            titleColumnMap[c.id] = row[c.id];
                        }
                    });
                }

                updateProgress('Data loading complete', 100);

            } catch (err) {
                console.error('Data refresh error:', err);

                // Set up empty state on error
                columns = [];
                allData = [];
                titleColumnMap = {};

                // Re-throw with more context
                throw new Error(`Failed to load data from worksheet "${worksheetName}": ${err.message}`);
            } finally {
                if (dataTableReader) {
                    try {
                        await dataTableReader.releaseAsync();
                    } catch (releaseError) {
                        console.warn('Error releasing data reader:', releaseError);
                    }
                }
            }
        }

        async function exportExcel() {
            try {
                updateProgress('Loading configurations...', 0);

                const allConfigs = await loadAllConfigurations();
                if (!allConfigs || Object.keys(allConfigs).length === 0) {
                    alert('No worksheets configured. Please configure at least one worksheet.');
                    return;
                }

                const wb = new ExcelJS.Workbook();
                wb.views = [{
                    x: 0, y: 0, width: 10000, height: 20000,
                    firstSheet: 0, activeTab: 0, visibility: 'visible'
                }];

                let firstFileName = null;
                let csvZipFileName = null;
                const worksheetNames = Object.keys(allConfigs).filter(name => name && name.trim() !== '');

                // Separate worksheets by export mode
                const excelWorksheets = [];
                const csvWorksheets = [];

                updateProgress('Categorizing worksheets...', 5);

                // First pass - categorize worksheets
                for (let i = 0; i < worksheetNames.length; i++) {
                    const worksheetName = worksheetNames[i];
                    const config = allConfigs[worksheetName];

                    if (!config) {
                        console.warn(`Skipping worksheet "${worksheetName}" because it has no configuration.`);
                        continue;
                    }

                    const exportMode = config.exportMode || 'formatted';
                    if (exportMode === 'datadump') {
                        csvWorksheets.push(worksheetName);
                    } else {
                        excelWorksheets.push(worksheetName);
                    }
                }

                // Get Excel workbook name from FIRST formatted worksheet
                if (excelWorksheets.length > 0) {
                    const firstWorksheetName = excelWorksheets[0];
                    const firstConfig = allConfigs[firstWorksheetName];

                    // If using field-based name, load data to get it
                    if (firstConfig.excelFileNameField) {
                        currentWorksheetName = firstWorksheetName;
                        await refreshWorksheetDataForExport(firstWorksheetName);
                        firstFileName = titleColumnMap[firstConfig.excelFileNameField];
                    }

                    // Fall back to direct name or default
                    if (!firstFileName) {
                        firstFileName = firstConfig.excelFileName || 'data_export';
                    }
                }

                // Get CSV zip filename from FIRST datadump worksheet
                if (csvWorksheets.length > 0) {
                    const firstCsvWorksheet = csvWorksheets[0];
                    const firstCsvConfig = allConfigs[firstCsvWorksheet];

                    // If using field-based name, load data to get it
                    if (firstCsvConfig.csvZipFileNameField) {
                        currentWorksheetName = firstCsvWorksheet;
                        await refreshWorksheetDataForExport(firstCsvWorksheet);
                        csvZipFileName = titleColumnMap[firstCsvConfig.csvZipFileNameField];
                    }

                    // Fall back to direct name or default
                    if (!csvZipFileName) {
                        csvZipFileName = firstCsvConfig.csvZipFileName || 'csv_export';
                    }
                }

                let hasExcelFile = false;
                let csvFiles = [];

                // Process Excel worksheets (formatted)
                if (excelWorksheets.length > 0) {
                    updateProgress('Processing Excel worksheets...', 10);

                    for (let i = 0; i < excelWorksheets.length; i++) {
                        const worksheetName = excelWorksheets[i];
                        const config = allConfigs[worksheetName];

                        updateProgress(`Processing Excel worksheet ${i + 1} of ${excelWorksheets.length}: ${worksheetName}`, 10 + (i / excelWorksheets.length) * 35);

                        // Set global variables for this worksheet
                        formatSettings = config.formatSettings || {};
                        fieldRenames = config.fieldRenames || {};
                        headerFormatSettings = config.headerFormatSettings || headerFormatSettings;
                        headerRowsCount = config.headerRowsCount || 0;
                        headerRowSettings = config.headerRowSettings || [];
                        tableTitle = config.tableTitle || '';
                        titleFontColor = config.titleFontColor || '000000';
                        titleBgColor = config.titleBgColor || 'F8F9FA';
                        titleAlignment = config.titleAlignment || 'center';
                        metricGroups = config.metricGroups || [];
                        subtotalLabels = config.subtotalLabels || {};
                        useCustomSubtotalLabels = config.useCustomSubtotalLabels || false;

                        // Clear caches for each worksheet
                        formatCache.clear();
                        conditionCache.clear();
                        rowColorCache.clear();

                        // Refresh data for this worksheet
                        currentWorksheetName = worksheetName;
                        await refreshWorksheetDataForExport(worksheetName);

                        // Skip if no pivot configuration
                        if (!Array.isArray(config.groupColumns) || config.groupColumns.length === 0) {
                            console.warn(`Skipping worksheet "${worksheetName}" because it has no pivot configuration.`);
                            continue;
                        }

                        // Create worksheet
                        let sheetName = config.sheetName;
                        if (!sheetName && config.sheetNameField) {
                            sheetName = titleColumnMap[config.sheetNameField] || worksheetName;
                        }
                        if (!sheetName) sheetName = worksheetName;
                        sheetName = sheetName.substring(0, 31).replace(/[\\/?*[\]]/g, '');

                        // Handle duplicate sheet names
                        let baseSheetName = sheetName;
                        let counter = 1;
                        while (wb.getWorksheet(sheetName)) {
                            sheetName = `${baseSheetName} (${counter})`;
                            counter++;
                        }

                        const ws = wb.addWorksheet(sheetName);

                        // Build Excel sheet (formatted)
                        const { pivotMap, rowKeys, colKeys } = await buildPivotMap(config);
                        const rowColorMap = buildRowColorMap(
                            config.groupColumns,
                            allData,
                            rowKeys,
                            config.rowFormatSettings || { field: null, rules: {} }
                        );

                        await buildExcelSheet(ws, config, pivotMap, rowKeys, colKeys, rowColorMap);
                        hasExcelFile = true;

                        // Memory cleanup for large datasets
                        if (allData.length > 50000) {
                            if (typeof global !== 'undefined' && typeof global.gc === 'function') {
                                global.gc();
                            }
                        }
                    }
                }

                // Process CSV worksheets (data dumps)
                if (csvWorksheets.length > 0) {
                    updateProgress('Processing CSV worksheets...', 50);

                    for (let i = 0; i < csvWorksheets.length; i++) {
                        const worksheetName = csvWorksheets[i];
                        const config = allConfigs[worksheetName];

                        updateProgress(`Processing CSV worksheet ${i + 1} of ${csvWorksheets.length}: ${worksheetName}`, 50 + (i / csvWorksheets.length) * 35);

                        // Set global variables for this worksheet
                        formatSettings = config.formatSettings || {};
                        fieldRenames = config.fieldRenames || {};
                        headerRowsCount = config.headerRowsCount || 0;
                        headerRowSettings = config.headerRowSettings || [];
                        tableTitle = config.tableTitle || '';
                        metricGroups = config.metricGroups || [];

                        // Refresh data for this worksheet
                        currentWorksheetName = worksheetName;
                        await refreshWorksheetDataForExport(worksheetName);

                        // Generate CSV with format settings applied
                        const dataDumpResult = await buildDataDump(config);
                        const csvResult = await generateCSV(dataDumpResult.data, dataDumpResult.columns, config);

                        // Determine CSV file name - use SHEET name
                        let csvFileName = config.sheetName;
                        if (!csvFileName && config.sheetNameField) {
                            csvFileName = titleColumnMap[config.sheetNameField] || worksheetName;
                        }
                        if (!csvFileName) {
                            csvFileName = worksheetName;
                        }

                        // Clean up file name
                        csvFileName = csvFileName.replace(/[\\/?*[\]]/g, '');

                        csvFiles.push({
                            content: csvResult.content,
                            fileName: csvFileName,
                            columnWidths: csvResult.columnWidths
                        });
                    }
                }

                updateProgress('Preparing downloads...', 90);

                // Download Excel file if we have one
                if (hasExcelFile) {
                    const buf = await wb.xlsx.writeBuffer();
                    const blob = new Blob([buf], {
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                    });
                    const url = URL.createObjectURL(blob);

                    let fileName = firstFileName;
                    if (!fileName.toLowerCase().endsWith('.xlsx')) fileName += '.xlsx';

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                // Download CSV files with correct zip name
                if (csvFiles && csvFiles.length > 0) {
                    const zipName = (csvZipFileName || 'csv_export').replace(/[\\/?*[\]]/g, '') + '.zip';
                    await downloadZip(csvFiles, zipName);
                }

                updateProgress('Downloads completed successfully!', 100);

                // Show summary message
                const totalFiles = (hasExcelFile ? 1 : 0) + csvFiles.length;
                const message = `Export completed! Downloaded ${totalFiles} file(s):\n` +
                    (hasExcelFile ? `â€¢ ${firstFileName}.xlsx (Formatted Excel)\n` : '') +
                    csvFiles.map(f => `â€¢ ${f.fileName}.csv (Data Dump with header rows & optimized columns)`).join('\n');

                setTimeout(() => alert(message), 500);

            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed: ' + error.message);
                throw error;
            }
        }

        // Optimized initialization with better error handling
        document.addEventListener("DOMContentLoaded", async () => {
            try {
                showLoading('Initializing extension...');

                await tableau.extensions.initializeAsync({
                    configure: () => {
                        const url = 'https://working-extension-excel.vercel.app/config.html';
                        tableau.extensions.ui
                            .displayDialogAsync(url, '', { width: 800, height: 600 })
                            .catch(err => console.error('Dialog error:', err));
                    }
                });

                updateProgress('Finding worksheets...', 20);

                const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                let worksheetName = "Download";
                let worksheet = worksheets.find(ws => ws.name === worksheetName);

                if (!worksheet) {
                    worksheet = worksheets[0];
                    worksheetName = worksheet.name;
                    console.warn(`"Download" worksheet not found, using "${worksheetName}" instead`);
                }

                updateProgress('Loading initial data...', 50);
                await refreshWorksheetDataForExport(worksheetName);
                await loadAllConfigurations();

                // Event listener setup with throttling
                let refreshTimeout = null;
                const throttledRefresh = async () => {
                    if (refreshTimeout) {
                        clearTimeout(refreshTimeout);
                    }
                    refreshTimeout = setTimeout(async () => {
                        try {
                            showLoading('Refreshing data...');
                            await refreshWorksheetDataForExport(worksheetName);
                            await loadAllConfigurations();
                            hideLoading();
                        } catch (error) {
                            console.error('Refresh error:', error);
                            hideLoading();
                        }
                    }, 1000); // Throttle to once per second
                };

                try {
                    if (tableau.TableauEventType && tableau.TableauEventType.SummaryDataChanged) {
                        worksheet.addEventListener(
                            tableau.TableauEventType.SummaryDataChanged,
                            throttledRefresh
                        );
                    } else {
                        worksheet.addEventListener('summarydatachanged', throttledRefresh);
                    }
                } catch (e) {
                    console.warn('Could not register data change listener:', e.message);
                }

                // Export button with debouncing
                let exportInProgress = false;
                document.getElementById('export-btn').addEventListener('click', async () => {
                    if (exportInProgress) {
                        console.warn('Export already in progress');
                        return;
                    }

                    exportInProgress = true;
                    showLoading('Starting export...');

                    try {
                        await refreshWorksheetDataForExport(worksheetName);
                        await loadAllConfigurations();
                        await exportExcel();
                    } catch (error) {
                        console.error('Export process error:', error);
                        alert('Export failed: ' + error.message);
                    } finally {
                        exportInProgress = false;
                        hideLoading();
                    }
                });

                updateProgress('Ready for export!', 100);
                setTimeout(hideLoading, 1000);

            } catch (error) {
                console.error('Initialization error:', error);
                alert('Initialization failed: ' + error.message);
                hideLoading();
            }
        });
    </script>
</body>

</html>